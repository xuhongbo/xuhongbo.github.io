<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 设计模式之构造函数模式 · xuhongbo</title><meta name="description" content="设计模式之构造函数模式 - xuhongbo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xuhongbo.com/atom.xml" title="xuhongbo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/abstract/" target="_self" class="nav-list-link">个人简介</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">设计模式之构造函数模式</h1><div class="post-info">Apr 5, 2016</div><div class="post-content"><p>构造函数大家都很熟悉了，不过如果你是新手，还是有必要来了解一下什么叫构造函数的。构造函数用于创建特定类型的对象——不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。<br><a id="more"></a></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>在 JavaScript 里，构造函数通常是认为用来实现实例的，JavaScript 没有类的概念，但是有特殊的构造函数。通过 new 关键字来调用定义的否早函数，你可以告诉 JavaScript 你要创建一个新对象并且新对象的成员声明都是构造函数里定义的。在构造函数内部，this 关键字引用的是新创建的对象。基本用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">    this.output= function () &#123;</div><div class="line">        return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var tom= new Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">var dudu= new Car(&quot;Dudu&quot;, 2010, 5000);</div><div class="line">console.log(tom.output());</div><div class="line">console.log(dudu.output());</div></pre></td></tr></table></figure>
<p>上面的例子是个非常简单的构造函数模式，但是有点小问题。首先是使用继承很麻烦了，其次 output()在每次创建对象的时候都重新定义了，最好的方法是让所有 Car 类型的实例都共享这个 output()方法，这样如果有大批量的实例的话，就会节约很多内存。</p>
<p>解决这个问题，我们可以使用如下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">    this.output= formatCar;</div><div class="line">&#125;</div><div class="line">function formatCar() &#123;</div><div class="line">    return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方式虽然可用，但是我们有如下更好的方式。</p>
<h2 id="构造函数与原型"><a href="#构造函数与原型" class="headerlink" title="构造函数与原型"></a>构造函数与原型</h2><p>JavaScript 里函数有个原型属性叫 prototype，当调用构造函数创建对象的时候，所有该构造函数原型的属性在新创建对象上都可用。按照这样，多个 Car 对象实例可以共享同一个原型，我们再扩展一下上例的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype</div><div class="line">主要是用来避免重写定义原型prototype对象</div><div class="line">*/</div><div class="line">Car.prototype.output= function () &#123;</div><div class="line">    return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">&#125;;</div><div class="line">var tom = new Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">var dudu = new Car(&quot;Dudu&quot;, 2010, 5000);</div><div class="line">console.log(tom.output());</div><div class="line">console.log(dudu.output());</div></pre></td></tr></table></figure>
<p>这里，output()单实例可以在所有 Car 对象实例里共享使用。</p>
<p>另外：我们推荐构造函数以大写字母开头，以便区分普通的函数。</p>
<h2 id="只能用-new-吗？"><a href="#只能用-new-吗？" class="headerlink" title="只能用 new 吗？"></a>只能用 new 吗？</h2><p>上面的例子对函数 car 都是用 new 来创建对象的，只有这一种方式么？其实还有别的方式，我们列举两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">    // 自定义一个output输出内容</div><div class="line">    this.output = function () &#123;</div><div class="line">        return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//方法1：作为函数调用</div><div class="line">Car(&quot;大叔&quot;, 2009, 20000);  //添加到window对象上</div><div class="line">console.log(window.output());</div><div class="line">//方法2：在另外一个对象的作用域内调用</div><div class="line">var o = new Object();</div><div class="line">Car.call(o, &quot;Dudu&quot;, 2010, 5000);</div><div class="line">console.log(o.output());</div></pre></td></tr></table></figure>
<p>该代码的方法 1 有点特殊，如果不适用 new 直接调用函数的话，this 指向的是全局对象 window，我们来验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//作为函数调用</div><div class="line">var tom = Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">console.log(typeof tom); // &quot;undefined&quot;</div><div class="line">console.log(window.output()); // &quot;大叔走了20000公里&quot;</div></pre></td></tr></table></figure>
<p>这时候对象 tom 是 undefined，而 window.output()会正确输出结果，而如果使用 new 关键字则没有这个问题，验证如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//使用new 关键字</div><div class="line">var tom = new Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">console.log(typeof tom); // &quot;object&quot;</div><div class="line">console.log(tom.output()); // &quot;大叔走了20000公里&quot;</div></pre></td></tr></table></figure>
<h2 id="强制使用-new"><a href="#强制使用-new" class="headerlink" title="强制使用 new"></a>强制使用 new</h2><p>上述的例子展示了不使用 new 的问题，那么我们有没有办法让构造函数强制使用 new 关键字呢，答案是肯定的，上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Car(model, year, miles) &#123;</div><div class="line">    if (!(this instanceof Car)) &#123;</div><div class="line">        return new Car(model, year, miles);</div><div class="line">    &#125;</div><div class="line">    this.model = model;</div><div class="line">    this.year = year;</div><div class="line">    this.miles = miles;</div><div class="line">    this.output = function () &#123;</div><div class="line">        return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var tom = new Car(&quot;大叔&quot;, 2009, 20000);</div><div class="line">var dudu = Car(&quot;Dudu&quot;, 2010, 5000);</div><div class="line">console.log(typeof tom); // &quot;object&quot;</div><div class="line">console.log(tom.output()); // &quot;大叔走了20000公里&quot;</div><div class="line">console.log(typeof dudu); // &quot;object&quot;</div><div class="line">console.log(dudu.output()); // &quot;Dudu走了5000公里&quot;</div></pre></td></tr></table></figure>
<p>通过判断 this 的 instanceof 是不是 Car 来决定返回 new Car 还是继续执行代码，如果使用的是 new 关键字，则(this instanceof Car)为真，会继续执行下面的参数赋值，如果没有用 new，(this instanceof Car)就为假，就会重新 new 一个实例返回。</p>
<h2 id="原始包装函数"><a href="#原始包装函数" class="headerlink" title="原始包装函数"></a>原始包装函数</h2><p>JavaScript 里有 3 中原始包装函数：number，string，boolean，有时候两种都用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 使用原始包装函数</div><div class="line">var s = new String(&quot;my string&quot;);</div><div class="line">var n = new Number(101);</div><div class="line">var b = new Boolean(true);</div><div class="line">// 推荐这种</div><div class="line">var s = &quot;my string&quot;;</div><div class="line">var n = 101;</div><div class="line">var b = true;</div></pre></td></tr></table></figure>
<p>推荐，只有在想保留数值状态的时候使用这些包装函数，关于区别可以参考下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 原始string</div><div class="line">var greet = &quot;Hello there&quot;;</div><div class="line">// 使用split()方法分割</div><div class="line">greet.split(&apos; &apos;)[0]; // &quot;Hello&quot;</div><div class="line">// 给原始类型添加新属性不会报错</div><div class="line">greet.smile = true;</div><div class="line">// 单没法获取这个值（18章ECMAScript实现里我们讲了为什么）</div><div class="line">console.log(typeof greet.smile); // &quot;undefined&quot;</div><div class="line">// 原始string</div><div class="line">var greet = new String(&quot;Hello there&quot;);</div><div class="line">// 使用split()方法分割</div><div class="line">greet.split(&apos; &apos;)[0]; // &quot;Hello&quot;</div><div class="line">// 给包装函数类型添加新属性不会报错</div><div class="line">greet.smile = true;</div><div class="line">// 可以正常访问新属性</div><div class="line">console.log(typeof greet.smile); // &quot;boolean&quot;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要讲解了构造函数模式的使用方法、调用方法以及new关键字的区别，希望大家在使用的时候有所注意。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/08/JavaScript/深入理解javascript/6S.O.L.I.D 五大原则之单一职责 SRP/" class="prev">上一篇</a><a href="/2016/03/25/JavaScript/深入理解javascript/17面向对象编程之一般理论/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>