<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 执行上下文（Execution Contexts） · xuhongbo</title><meta name="description" content="执行上下文（Execution Contexts） - xuhongbo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xuhongbo.com/atom.xml" title="xuhongbo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/abstract/" target="_self" class="nav-list-link">个人简介</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">执行上下文（Execution Contexts）</h1><div class="post-info">Jan 16, 2016</div><div class="post-content"><p>从本章开始，我将陆续（翻译、转载、整理）<a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">http://dmitrysoshnikov.com/</a>网站关于 ECMAScript 标标准理解的好文。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>每次当控制器转到 ECMAScript 可执行代码的时候，即会进入到一个执行上下文。执行上下文(简称-EC)是 ECMA-262 标准里的一个抽象概念，用于同可执行代码(executable code)概念进行区分。<br><a id="more"></a><br>标准规范没有从技术实现的角度定义EC的准确类型和结构，这应该是具体实现 ECMAScript 引擎时要考虑的问题。</p>
<p>活动的执行上下文组在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(global context)，而顶部就是当前(活动的)执行上下文。堆栈在EC类型进入和退出上下文的时候被修改（推入或弹出）。</p>
<h2 id="可执行代码类型"><a href="#可执行代码类型" class="headerlink" title="可执行代码类型"></a>可执行代码类型</h2><p>可执行代码的类型这个概念与执行上下文的抽象概念是有关系的。在某些时刻，可执行代码与执行上下文完全有可能是等价的。</p>
<p>例如，我们可以定义执行上下文堆栈是一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ECStack = [];</div></pre></td></tr></table></figure>
<p>每次进入 function (即使 function 被递归调用或作为构造函数) 的时候或者内置的 eval 函数工作的时候，这个堆栈都会被压入。</p>
<h2 id="全局代码"><a href="#全局代码" class="headerlink" title="全局代码"></a>全局代码</h2><p>这种类型的代码是在”程序”级处理的：例如加载外部的 js 文件或者本地标签内的代码。全局代码不包括任何 function 体内的代码。</p>
<p>在初始化（程序启动）阶段，ECStack 是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ECStack = [</div><div class="line">  globalContext</div><div class="line">];</div></pre></td></tr></table></figure>
<h2 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h2><p>当进入 funtion 函数代码(所有类型的 funtions)的时候，ECStack 被压入新元素。需要注意的是，具体的函数代码不包括内部函数(inner functions)代码。如下所示，我们使函数自己调自己的方式递归一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function  foo(bar) &#123;</div><div class="line">  if (bar) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  foo(true);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>那么，ECStack 以如下方式被改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 第一次foo的激活调用</div><div class="line">ECStack = [</div><div class="line">  &lt;foo&gt; functionContext</div><div class="line">  globalContext</div><div class="line">];</div><div class="line">// foo的递归激活调用</div><div class="line">ECStack = [</div><div class="line">  &lt;foo&gt; functionContext – recursively</div><div class="line">  &lt;foo&gt; functionContext</div><div class="line">  globalContext</div><div class="line">];</div></pre></td></tr></table></figure>
<p>每次 return 的时候，都会退出当前执行上下文的，相应地 ECStack 就会弹出，栈指针会自动移动位置，这是一个典型的堆栈实现方式。一个抛出的异常如果没被截获的话也有可能从一个或多个执行上下文退出。相关代码执行完以后，ECStac k只会包含全局上下文(global context)，一直到整个应用程序结束。</p>
<h2 id="Eval-代码"><a href="#Eval-代码" class="headerlink" title="Eval 代码"></a>Eval 代码</h2><p>eval 代码有点儿意思。它有一个概念： 调用上下文(calling context),例如，eval 函数调用的时候产生的上下文。eval(变量或函数声明)活动会影响调用上下文(calling context)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eval(&apos;var x = 10&apos;);</div><div class="line">(function foo() &#123;</div><div class="line">  eval(&apos;var y = 20&apos;);</div><div class="line">&#125;)();</div><div class="line">alert(x); // 10</div><div class="line">alert(y); // &quot;y&quot; 提示没有声明</div></pre></td></tr></table></figure>
<p>ECStac k的变化过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ECStack = [</div><div class="line">  globalContext</div><div class="line">];</div><div class="line">// eval(&apos;var x = 10&apos;);</div><div class="line">ECStack.push(</div><div class="line">  evalContext,</div><div class="line">  callingContext: globalContext</div><div class="line">);</div><div class="line">// eval exited context</div><div class="line">ECStack.pop();</div><div class="line">// foo funciton call</div><div class="line">ECStack.push(&lt;foo&gt; functionContext);</div><div class="line">// eval(&apos;var y = 20&apos;);</div><div class="line">ECStack.push(</div><div class="line">  evalContext,</div><div class="line">  callingContext: &lt;foo&gt; functionContext</div><div class="line">);</div><div class="line">// return from eval</div><div class="line">ECStack.pop();</div><div class="line">// return from foo</div><div class="line">ECStack.pop();</div></pre></td></tr></table></figure>
<p>也就是一个非常普通的逻辑调用堆栈。</p>
<p>在版本号 1.7 以上的 SpiderMonkey(内置于 Firefox，Thunderbird)的实现中，可以把调用上下文作为第二个参数传递给 eval。那么，如果这个上下文存在，就有可能影响“私有”(有人喜欢这样叫它)变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  var x = 1;</div><div class="line">  return function () &#123; alert(x); &#125;;</div><div class="line">&#125;;</div><div class="line">var bar = foo();</div><div class="line">bar(); // 1</div><div class="line">eval(&apos;x = 2&apos;, bar); // 传入上下文，影响了内部的var x 变量</div><div class="line">bar(); // 2</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇文章是后面分析其他跟执行上下文相关的主题(例如变量对象，作用域链，等等)的最起码的理论基础，这些主题将在后续章节中讲到。</p>
<h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p>这篇文章的内容在 ECMA-262-3 标准规范中对应的章节<a href="http://bclary.com/2004/11/07/#a-10" target="_blank" rel="external">— 10. Execution Contexts</a>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/01/16/深入理解javascript/2揭秘命名函数表达式/" class="prev">上一篇</a><a href="/2016/01/15/深入理解javascript/14作用域链(Scope Chain)/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>