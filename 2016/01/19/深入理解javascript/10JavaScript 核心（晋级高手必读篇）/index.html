<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript 核心（晋级高手必读篇） · xuhongbo</title><meta name="description" content="JavaScript 核心（晋级高手必读篇） - xuhongbo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xuhongbo.com/atom.xml" title="xuhongbo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript 核心（晋级高手必读篇）</h1><div class="post-info">Jan 19, 2016</div><div class="post-content"><p>我们首先来看一下对象[Object]的概念，这也是 ECMASript 中最基本的概念。</p>
<h2 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象 Object"></a>对象 Object</h2><p>ECMAScript 是一门高度抽象的面向对象(object-oriented)语言，用以处理 Objects 对象。当然，也有基本类型，但是必要时，也需要转换成 object 对象来用。<br><a id="more"></a></p>
<blockquote>
<p>Object 是一个属性的集合，并且都拥有一个单独的原型对象[prototype object]。这个原型对象[prototype object]可以是一个 object 或者 null 值。</p>
</blockquote>
<p>让我们来举一个基本 Object 的例子，首先我们要清楚，一个 Object 的 prototype 是一个内部的[[prototype]]属性的引用。</p>
<p>不过一般来说，我们会使用<strong>&lt;内部属性名&gt;</strong> 下划线来代替双括号，例如<strong>proto</strong>(这是某些脚本引擎比如 SpiderMonkey 的对于原型概念的具体实现，尽管并非标准)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上述代码 foo 对象有两个显式的属性[explicit own properties]和一个自带隐式的<strong>proto</strong> 属性[implicit<strong>proto</strong> property]，指向 foo 的原型。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/1.png" alt="img"></p>
<p>图 1. 一个含有原型的基本对象</p>
<p>为什么需要原型呢，让我们考虑原型链的概念来回答这个问题。</p>
<h2 id="原型链（Prototype-chain）"><a href="#原型链（Prototype-chain）" class="headerlink" title="原型链（Prototype chain）"></a>原型链（Prototype chain）</h2><p>原型对象也是普通的对象，并且也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链（prototype chain）。</p>
<blockquote>
<p>原型链是一个由对象组成的有限对象链由于实现继承和共享属性。</p>
</blockquote>
<p>想象一个这种情况，2 个对象，大部分内容都一样，只有一小部分不一样，很明显，在一个好的设计模式中，我们会需要重用那部分相同的，而不是在每个对象中重复定义那些相同的方法或者属性。在基于类[class-based]的系统中，这些重用部分被称为类的继承 – 相同的部分放入 class A，然后 class B 和 class C 从 A 继承，并且可以声明拥有各自的独特的东西。</p>
<p>ECMAScript 没有类的概念。但是，重用[reuse]这个理念没什么不同（某些方面，甚至比 class-更加灵活），可以由 prototype chain 原型链来实现。这种继承被称为 delegation based inheritance-基于继承的委托，或者更通俗一些，叫做原型继承。</p>
<p>类似于类”A”，”B”，”C”，在ECMAScript中尼创建对象类”a”，”b”，”c”，相应地， 对象“a” 拥有对象“b”和”c”的共同部分。同时对象“b”和”c”只包含它们自己的附加属性或方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">  x: 10,</div><div class="line">  calculate: function (z) &#123;</div><div class="line">    return this.x + this.y + z</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var b = &#123;</div><div class="line">  y: 20,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line">var c = &#123;</div><div class="line">  y: 30,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line">// 调用继承过来的方法</div><div class="line">b.calculate(30); // 60</div><div class="line">c.calculate(40); // 80</div></pre></td></tr></table></figure>
<p>这样看上去是不是很简单啦。b 和 c 可以使用 a 中定义的 calculate 方法，这就是有原型链来[prototype chain]实现的。</p>
<p>原理很简单:如果在对象 b 中找不到 calculate 方法(也就是对象 b 中没有这个 calculate 属性), 那么就会沿着原型链开始找。如果这个 calculate 方法在 b 的 prototype 中没有找到，那么就会沿着原型链找到 a 的 prototype，一直遍历完整个原型链。记住，一旦找到，就返回第一个找到的属性或者方法。因此，第一个找到的属性成为继承属性。如果遍历完整个原型链，仍然没有找到，那么就会返回 undefined。</p>
<p>注意一点，this 这个值在一个继承机制中，仍然是指向它原本属于的对象，而不是从原型链上找到它时，它所属于的对象。例如，以上的例子，this.y 是从 b 和 c 中获取的，而不是 a。当然，你也发现了 this.x 是从 a 取的，因为是通过原型链机制找到的。</p>
<p>如果一个对象的 prototype 没有显示的声明过或定义过，那么<strong>prototype</strong>的默认值就是 object.prototype，而 object.prototype 也会有一个<strong>prototype</strong>， 这个就是原型链的终点了，被设置为 null。</p>
<p>下面的图示就是表示了上述 a，b，c 的继承关系</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/2.png" alt="img"></p>
<p>图 2. 原型链</p>
<p>原型链通常将会在这样的情况下使用：对象拥有 相同或相似的状态结构(same or similar state structure) （即相同的属性集合）与不同的状态值(different state values)。在这种情况下，我们可以使用 构造函数(Constructor) 在特定模式(specified pattern) 下创建对象。</p>
<h2 id="构造函数-Constructor"><a href="#构造函数-Constructor" class="headerlink" title="构造函数(Constructor)"></a>构造函数(Constructor)</h2><p>除了创建对象，构造函数(constructor) 还做了另一件有用的事情—自动为创建的新对象设置了原型对象(prototype object) 。原型对象存放于 ConstructorFunction.prototype 属性中。</p>
<p>例如，我们重写之前例子，使用构造函数创建对象“b”和“c”，那么对象”a”则扮演了“Foo.prototype”这个角色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// 构造函数</div><div class="line">function Foo(y) &#123;</div><div class="line">  // 构造函数将会以特定模式创建对象：被创建的对象都会有&quot;y&quot;属性</div><div class="line">  this.y = y;</div><div class="line">&#125;</div><div class="line">// &quot;Foo.prototype&quot;存放了新建对象的原型引用</div><div class="line">// 所以我们可以将之用于定义继承和共享属性或方法</div><div class="line">// 所以，和上例一样，我们有了如下代码：</div><div class="line">// 继承属性&quot;x&quot;</div><div class="line">Foo.prototype.x = 10; </div><div class="line">// 继承方法&quot;calculate&quot;</div><div class="line">Foo.prototype.calculate = function (z) &#123;</div><div class="line">  return this.x + this.y + z;</div><div class="line">&#125;; </div><div class="line">// 使用foo模式创建 &quot;b&quot; and &quot;c&quot;</div><div class="line">var b = new Foo(20);</div><div class="line">var c = new Foo(30);</div><div class="line">// 调用继承的方法</div><div class="line">b.calculate(30); // 60</div><div class="line">c.calculate(40); // 80</div><div class="line">// 让我们看看是否使用了预期的属性 </div><div class="line">console.log(</div><div class="line">  b.__proto__ === Foo.prototype, // true</div><div class="line">  c.__proto__ === Foo.prototype, // true</div><div class="line">  // &quot;Foo.prototype&quot;自动创建了一个特殊的属性&quot;constructor&quot;</div><div class="line">  // 指向a的构造函数本身</div><div class="line">  // 实例&quot;b&quot;和&quot;c&quot;可以通过授权找到它并用以检测自己的构造函数</div><div class="line">  b.constructor === Foo, // true</div><div class="line">  c.constructor === Foo, // true</div><div class="line">  Foo.prototype.constructor === Foo // true</div><div class="line">  b.calculate === b.__proto__.calculate, // true</div><div class="line">  b.__proto__.calculate === Foo.prototype.calculate // true </div><div class="line">);</div></pre></td></tr></table></figure>
<p>上述代码可表示为如下的关系：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/3.png" alt="img"></p>
<p>图 3. 构造函数与对象之间的关系</p>
<p>上述图示可以看出，每一个 object 都有一个 prototype. 构造函数 Foo 也拥有自己的<strong>proto</strong>，也就是 Function.prototype，而 Function.prototype 的<strong>proto</strong>指向了 Object.prototype。 重申一遍，Foo.prototype 只是一个显式的属性，也就是 b 和 c 的<strong>proto</strong>属性。</p>
<p>这个问题完整和详细的解释可以在大叔即将翻译的第 18、19 两章找到。有两个部分：<code>面向对象编程.一般理论(OOP. The general theory)</code>，描述了不同的面向对象的范式与风格(OOP paradigms and stylistics)，以及与ECMAScript的比较， <code>面向对象编程.ECMAScript实现(OOP. ECMAScript implementation)</code>，专门讲述了 ECMAScript 中的面向对象编程。</p>
<p>现在，我们已经了解了基本的 object 原理，那么我们接下去来看看 ECMAScript 里面的程序执行环境[runtime program execution]. 这就是通常称为的“执行上下文堆栈”[execution context stack]。每一个元素都可以抽象的理解为 object。你也许发现了，没错，在 ECMAScript 中，几乎处处都能看到 object 的身影。</p>
<h2 id="执行上下文栈-Execution-Context-Stack"><a href="#执行上下文栈-Execution-Context-Stack" class="headerlink" title="执行上下文栈(Execution Context Stack)"></a>执行上下文栈(Execution Context Stack)</h2><p>在 ECMASscript 中的代码有三种类型：global，function 和 eval。</p>
<p>每一种代码的执行都需要依赖自身的上下文。当然 global 的上下文可能涵盖了很多的 function 和 eval 的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval 函数的每一次执行，也会进入 eval 执行中的上下文，判断应该从何处获取变量的值。</p>
<p>注意，一个 function 可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(bar) &#123;&#125;</div><div class="line">// 调用相同的function，每次都会产生3个不同的上下文</div><div class="line">//（包含不同的状态，例如参数bar的值）</div><div class="line">foo(10);</div><div class="line">foo(20);</div><div class="line">foo(30);</div></pre></td></tr></table></figure>
<p>一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。</p>
<p>激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。</p>
<p>当一个 caller 激活了一个 callee，那么这个 caller 就会暂停它自身的执行，然后将控制权交给这个 callee. 于是这个 callee 被放入堆栈，称为进行中的上下文[running/active execution context]。当这个 callee 的上下文结束之后，会把控制权再次交给它的 caller，然后 caller 会在刚才暂停的地方继续执行。在这个 caller 结束之后，会继续触发其他的上下文。一个 callee 可以用返回（return）或者抛出异常（exception）来结束自身的上下文。</p>
<p>如下图，所有的 ECMAScript 的程序执行都可以看做是一个执行上下文堆栈[execution context (EC) stack]。堆栈的顶部就是处于激活状态的上下文。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/4.png" alt="img"></p>
<p>图 4. 执行上下文栈</p>
<p>当一段程序开始时，会先进入全局执行上下文环境[global execution context], 这个也是堆栈中最底部的元素。此全局程序会开始初始化，初始化生成必要的对象[objects]和函数[functions]. 在此全局上下文执行的过程中，它可能会激活一些方法（当然是已经初始化过的），然后进入他们的上下文环境，然后将新的元素压入堆栈。在这些初始化都结束之后，这个系统会等待一些事件（例如用户的鼠标点击等），会触发一些方法，然后进入一个新的上下文环境。</p>
<p>见图5，有一个函数上下文“EC1″和一个全局上下文“Global EC”，下图展现了从“Global EC”进入和退出“EC1″时栈的变化:</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/5.png" alt="img"></p>
<p>图 5. 执行上下文栈的变化</p>
<p>ECMAScript 运行时系统就是这样管理代码的执行。</p>
<p>关于ECMAScript执行上下文栈的内容请查阅本系列教程的<code>第11章执行上下文(Execution context)</code>。</p>
<p>如上所述，栈中每一个执行上下文可以表示为一个对象。让我们看看上下文对象的结构以及执行其代码所需的状态(state) 。</p>
<h2 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h2><p>一个执行的上下文可以抽象的理解为 object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。这个图示就是一个 context 的结构。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/6.png" alt="img"></p>
<p>图 6. 上下文结构</p>
<p>除了这 3 个所需要的属性(<code>变量对象(variable object)</code>，<code>this 指针(this value)</code>，<code>作用域链(scope chain)</code> )，执行上下文根据具体实现还可以具有任意额外属性。接着，让我们仔细来看看这三个属性。</p>
<h2 id="变量对象-Variable-Object"><a href="#变量对象-Variable-Object" class="headerlink" title="变量对象(Variable Object)"></a>变量对象(Variable Object)</h2><ul>
<li>变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。</li>
<li>它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</li>
</ul>
<blockquote>
<p>注意：函数表达式[function expression]（而不是函数声明[function declarations，区别请参考本系列第2章]）是不包含在VO[variable object]里面的。</p>
</blockquote>
<p>变量对象（Variable Object）是一个抽象的概念，不同的上下文中，它表示使用不同的 object。例如，在 global 全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。</p>
<p>让我们看看下面例子中的全局执行上下文情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var foo = 10;</div><div class="line">function bar() &#123;&#125; // // 函数声明</div><div class="line">(function baz() &#123;&#125;); // 函数表达式</div><div class="line">console.log(</div><div class="line">  this.foo == foo, // true</div><div class="line">  window.bar == bar // true</div><div class="line">);</div><div class="line">console.log(baz); // 引用错误，baz没有被定义</div></pre></td></tr></table></figure>
<p>全局上下文中的变量对象(VO)会有如下属性：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/7.png" alt="img"></p>
<p>图 7. 全局变量对象</p>
<p>如上所示，函数“baz”如果作为函数表达式则不被不被包含于变量对象。这就是在函数外部尝试访问产生引用错误(ReferenceError) 的原因。请注意，ECMAScript 和其他语言相比(比如 C/C++)，仅有函数能够创建新的作用域。在函数内部定义的变量与内部函数，在外部非直接可见并且不污染全局对象。使用 eval 的时候，我们同样会使用一个新的(eval创建)执行上下文。eval 会使用全局变量对象或调用者的变量对象(eval 的调用来源)。</p>
<p>那函数以及自身的变量对象又是怎样的呢?在一个函数上下文中，变量对象被表示为活动对象(activation object)。</p>
<h2 id="活动对象-activation-object"><a href="#活动对象-activation-object" class="headerlink" title="活动对象(activation object)"></a>活动对象(activation object)</h2><p>当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。</p>
<p>即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象 arguments 。</p>
<p>考虑下面的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(x, y) &#123;</div><div class="line">  var z = 30;</div><div class="line">  function bar() &#123;&#125; // 函数声明</div><div class="line">  (function baz() &#123;&#125;); // 函数表达式</div><div class="line">&#125;</div><div class="line">foo(10, 20);</div></pre></td></tr></table></figure>
<p>“foo”函数上下文的下一个激活对象(AO)如下图所示：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/8.png" alt="img"></p>
<p>图 8. 激活对象</p>
<p>同样道理，function expression 不在 AO 的行列。</p>
<p>对于这个 AO 的详细内容可以通过本系列教程第 9 章找到。</p>
<p>我们接下去要讲到的是第三个主要对象。众所周知，在 ECMAScript 中，我们会用到内部函数[inner functions]，在这些内部函数中，我们可能会引用它的父函数变量，或者全局的变量。我们把这些变量对象成为上下文作用域对象[scope object of the context]. 类似于上面讨论的原型链[prototype chain]，我们在这里称为作用域链[scope chain]。</p>
<h2 id="作用域链-Scope-Chains"><a href="#作用域链-Scope-Chains" class="headerlink" title="作用域链(Scope Chains)"></a>作用域链(Scope Chains)</h2><blockquote>
<p>作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的标识符(identifiers) 。</p>
</blockquote>
<p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</p>
<p>标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。例如，当一个函数在自身函数体内需要引用一个变量，但是这个变量并没有在函数内部声明（或者也不是某个参数名），那么这个变量就可以称为自由变量[free variable]。那么我们搜寻这些自由变量就需要用到作用域链。</p>
<p>在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量 VO 和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如 with 或者 catch 语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses 指的是 catch从句，如 catch(e)，这会产生异常对象，导致作用域变更]。</p>
<p>当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">(function foo() &#123;</div><div class="line">  var y = 20;</div><div class="line">  (function bar() &#123;</div><div class="line">    var z = 30;</div><div class="line">    // &quot;x&quot;和&quot;y&quot;是自由变量</div><div class="line">    // 会在作用域链的下一个对象中找到（函数”bar”的互动对象之后）</div><div class="line">    console.log(x + y + z);</div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>我们假设作用域链的对象联动是通过一个叫做<strong>parent</strong>的属性，它是指向作用域链的下一个对象。这可以在 Rhino Code 中测试一下这种流程，这种技术也确实在 ES5 环境中实现了(有一个称为 outer 链接)。当然也可以用一个简单的数据来模拟这个模型。使用<strong>parent</strong>的概念，我们可以把上面的代码演示成如下的情况。（因此，父级变量是被存在函数的[[Scope]]属性中的）。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/9.png" alt="img"></p>
<p>图 9. 作用域链</p>
<p>在代码执行过程中，如果使用 with 或者 catch 语句就会改变作用域链。而这些对象都是一些简单对象，他们也会有原型链。这样的话，作用域链会从两个维度来搜寻。</p>
<ol>
<li>首先在原本的作用域链</li>
<li>每一个链接点的作用域的链（如果这个链接点是有 prototype 的话）</li>
</ol>
<p>我们再看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = 10;</div><div class="line">var w = 20;</div><div class="line">var y = 30;</div><div class="line">// 在SpiderMonkey全局对象里</div><div class="line">// 例如，全局上下文的变量对象是从&quot;Object.prototype&quot;继承到的</div><div class="line">// 所以我们可以得到“没有声明的全局变量”</div><div class="line">// 因为可以从原型链中获取</div><div class="line">console.log(x); // 10</div><div class="line">(function foo() &#123;</div><div class="line">  // &quot;foo&quot; 是局部变量</div><div class="line">  var w = 40;</div><div class="line">  var x = 100;</div><div class="line">  // &quot;x&quot; 可以从&quot;Object.prototype&quot;得到，注意值是10哦</div><div class="line">  // 因为&#123;z: 50&#125;是从它那里继承的</div><div class="line">  with (&#123;z: 50&#125;) &#123;</div><div class="line">    console.log(w, x, y , z); // 40, 10, 30, 50</div><div class="line">  &#125;</div><div class="line">  // 在&quot;with&quot;对象从作用域链删除之后</div><div class="line">  // x又可以从foo的上下文中得到了，注意这次值又回到了100哦</div><div class="line">  // &quot;w&quot; 也是局部变量</div><div class="line">  console.log(x, w); // 100, 40</div><div class="line">  // 在浏览器里</div><div class="line">  // 我们可以通过如下语句来得到全局的w值</div><div class="line">  console.log(window.w); // 20</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>我们就会有如下结构图示。这表示，在我们去搜寻<strong>parent</strong>之前，首先会去<strong>proto</strong>的链接中。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/10.png" alt="img"></p>
<p>图 10. with 增大的作用域链</p>
<p>注意，不是所有的全局对象都是由 Object.prototype 继承而来的。上述图示的情况可以在 SpiderMonkey 中测试。</p>
<p>只要所有外部函数的变量对象都存在，那么从内部函数引用外部数据则没有特别之处——我们只要遍历作用域链表，查找所需变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被 销毁(destroyed) ，同时内部函数将会从外部函数中返回。此外，这个返回的函数之后可能会在其他的上下文中被激活，那么如果一个之前被终止的含有一些自由变量的上下文又被激活将会怎样?通常来说，解决这个问题的概念在 ECMAScrip t中与作用域链直接相关，被称为 (词法)闭包((lexical) closure)。</p>
<h2 id="闭包-Closures"><a href="#闭包-Closures" class="headerlink" title="闭包(Closures)"></a>闭包(Closures)</h2><p>在 ECMAScript 中，函数是“第一类”对象。这个名词意味着函数可以作为参数被传递给其他函数使用 (在这种情况下，函数被称为“funargs”——“functional arguments”的缩写[译注：这里不知翻译为泛函参数是否恰当])。接收“funargs”的函数被称之为 高阶函数(higher-order functions) ，或者更接近数学概念的话，被称为 运算符(operators) 。其他函数的运行时也会返回函数，这些返回的函数被称为 function valued 函数 (有 functional value 的函数)。</p>
<p>“funargs”与“functional values”有两个概念上的问题，这两个子问题被称为“Funarg problem” (“泛函参数问题”)。要准确解决泛函参数问题，需要引入 闭包(closures) 到的概念。让我们仔细描述这两个问题(我们可以见到，在 ECMAScript 中使用了函数的[[Scope]]属性来解决这个问题)。</p>
<p>“funarg problem”的一个子问题是“upward funarg problem”[译注：或许可以翻译为：向上查找的函数参数问题]。当一个函数从其他函数返回到外部的时候，这个问题将会出现。要能够在外部上下文结束时，进入外部上下文的变量，内部函数 在创建的时候(at creation moment) 需要将之存储进[[Scope]]属性的父元素的作用域中。然后当函数被激活时，上下文的作用域链表现为激活对象与[[Scope]]属性的组合(事实上，可以在上图见到)：</p>
<blockquote>
<p>Scope chain = Activation object + [[Scope]]<br>作用域链 = 活动对象 + [[Scope]]</p>
</blockquote>
<p>请注意，最主要的事情是——函数在被创建时保存外部作用域，是因为这个 被保存的作用域链(saved scope chain) 将会在未来的函数调用中用于变量查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  var x = 10;</div><div class="line">  return function bar() &#123;</div><div class="line">    console.log(x);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">// &quot;foo&quot;返回的也是一个function</div><div class="line">// 并且这个返回的function可以随意使用内部的变量x</div><div class="line">var returnedFunction = foo();</div><div class="line">// 全局变量 &quot;x&quot;</div><div class="line">var x = 20;</div><div class="line">// 支持返回的function</div><div class="line">returnedFunction(); // 结果是10而不是20</div></pre></td></tr></table></figure>
<p>这种形式的作用域称为静态作用域[static/lexical scope]。上面的 x 变量就是在函数 bar 的[[Scope]]中搜寻到的。理论上来说，也会有动态作用域[dynamic scope], 也就是上述的 x 被解释为 20，而不是 10. 但是 EMCAScript 不使用动态作用域。</p>
<p>“funarg problem”的另一个类型就是自上而下[”downward funarg problem”].在这种情况下，父级的上下会存在，但是在判断一个变量值的时候会有多义性。也就是，这个变量究竟应该使用哪个作用域。是在函数创建时的作用域呢，还是在执行时的作用域呢？为了避免这种多义性，可以采用闭包，也就是使用静态作用域。</p>
<p>请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 全局变量 &quot;x&quot;</div><div class="line">var x = 10;</div><div class="line">// 全局function</div><div class="line">function foo() &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;</div><div class="line">(function (funArg) &#123;</div><div class="line">  // 局部变量 &quot;x&quot;</div><div class="line">  var x = 20;</div><div class="line">  // 这不会有歧义</div><div class="line">  // 因为我们使用&quot;foo&quot;函数的[[Scope]]里保存的全局变量&quot;x&quot;,</div><div class="line">  // 并不是caller作用域的&quot;x&quot;</div><div class="line">  funArg(); // 10, 而不是20</div><div class="line">&#125;)(foo); // 将foo作为一个&quot;funarg&quot;传递下去</div></pre></td></tr></table></figure>
<p>从上述的情况，我们似乎可以断定，在语言中，使用静态作用域是闭包的一个强制性要求。不过，在某些语言中，会提供动态和静态作用域的结合，可以允许开发员选择哪一种作用域。但是在 ECMAScript 中，只采用了静态作用域。所以 ECMAScript 完全支持使用[[Scope]]的属性。我们可以给闭包得出如下定义：</p>
<blockquote>
<p>闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</p>
</blockquote>
<p>请注意，因为每一个普通函数在创建时保存了[[Scope]]，理论上，ECMAScript 中所有函数都是闭包。</p>
<p>还有一个很重要的点，几个函数可能含有相同的父级作用域（这是一个很普遍的情况，例如有好几个内部或者全局的函数）。在这种情况下，在[[Scope]]中存在的变量是会共享的。一个闭包中变量的变化，也会影响另一个闭包的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function baz() &#123;</div><div class="line">  var x = 1;</div><div class="line">  return &#123;</div><div class="line">    foo: function foo() &#123; return ++x; &#125;,</div><div class="line">    bar: function bar() &#123; return --x; &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">var closures = baz();</div><div class="line">console.log(</div><div class="line">  closures.foo(), // 2</div><div class="line">  closures.bar()  // 1</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上述代码可以用这张图来表示：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/11.png" alt="img"></p>
<p>图 11. 共享的[[Scope]]</p>
<p>在某个循环中创建多个函数时，上图会引发一个困惑。如果在创建的函数中使用循环变量(如”k”)，那么所有的函数都使用同样的循环变量，导致一些程序员经常会得不到预期值。现在清楚为什么会产生如此问题了——因为所有函数共享同一个[[Scope]]，其中循环变量为最后一次复赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = function () &#123;</div><div class="line">    alert(k);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">data[0](); // 3, but not 0</div><div class="line">data[1](); // 3, but not 1</div><div class="line">data[2](); // 3, but not 2</div></pre></td></tr></table></figure>
<p>有一些用以解决这类问题的技术。其中一种技巧是在作用域链中提供一个额外的对象，比如增加一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = (function (x) &#123;</div><div class="line">    return function () &#123;</div><div class="line">      alert(x);</div><div class="line">    &#125;;</div><div class="line">  &#125;)(k); // 将k当做参数传递进去</div><div class="line">&#125; </div><div class="line">// 结果正确</div><div class="line">data[0](); // 0</div><div class="line">data[1](); // 1</div><div class="line">data[2](); // 2</div></pre></td></tr></table></figure>
<p>闭包理论的深入研究与具体实践可以在本系列教程第 16 章闭包(Closures)中找到。如果想得到关于作用域链的更多信息，可以参照本系列教程第 14 章作用域链(Scope chain)。</p>
<p>下一章节将会讨论一个执行上下文的最后一个属性——this 指针的概念。</p>
<h2 id="This-指针"><a href="#This-指针" class="headerlink" title="This 指针"></a>This 指针</h2><blockquote>
<p>this适合执行的上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象<a href="激活执行上下文的上下文">context object</a>。</p>
</blockquote>
<p>任何对象都可以作为上下文的 this 值。我想再次澄清对与 ECMAScript 中，与执行上下文相关的一些描述——特别是 this 的误解。通常，this 被错误地，描述为变量对象的属性。最近比如在这本书中就发现了(尽管书中提及 this 的那一章还不错)。 请牢记：</p>
<blockquote>
<p>this是执行上下文环境的一个属性，而不是某个变量对象的属性。</p>
</blockquote>
<p>这个特点很重要，因为和变量不同，this 是没有一个类似搜寻变量的过程。当你在代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this 的值只取决中进入上下文时的情况。</p>
<p>顺便说一句，和 ECMAScript 不同，Python 有一个 self 的参数，和 this 的情况差不多，但是可以在执行过程中被改变。在 ECMAScript 中，是不可以给 this 赋值的，因为，还是那句话，this 不是变量。</p>
<p>在 global context(全局上下文)中，this 的值就是指全局这个对象，这就意味着，this 值就是这个变量本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">console.log(</div><div class="line">  x, // 10</div><div class="line">  this.x, // 10</div><div class="line">  window.x // 10</div><div class="line">);</div></pre></td></tr></table></figure>
<p>在函数上下文[function context]中，this 会可能会根据每次的函数调用而成为不同的值 .this 会由每一次 caller 提供，caller 是通过调用表达式[call expression]产生的（也就是这个函数如何被激活调用的）。例如，下面的例子中 foo 就是一个 callee，在全局上下文中被激活。下面的例子就表明了不同的 caller 引起 this 的不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// &quot;foo&quot;函数里的alert没有改变</div><div class="line">// 但每次激活调用的时候this是不同的</div><div class="line">function foo() &#123;</div><div class="line">  alert(this);</div><div class="line">&#125;</div><div class="line">// caller 激活 &quot;foo&quot;这个callee，</div><div class="line">// 并且提供&quot;this&quot;给这个 callee</div><div class="line">foo(); // 全局对象</div><div class="line">foo.prototype.constructor(); // foo.prototype</div><div class="line">var bar = &#123;</div><div class="line">  baz: foo</div><div class="line">&#125;;</div><div class="line">bar.baz(); // bar</div><div class="line">(bar.baz)(); // also bar</div><div class="line">(bar.baz = bar.baz)(); // 这是一个全局对象</div><div class="line">(bar.baz, bar.baz)(); // 也是全局对象</div><div class="line">(false || bar.baz)(); // 也是全局对象</div><div class="line">var otherFoo = bar.baz;</div><div class="line">otherFoo(); // 还是全局对象</div></pre></td></tr></table></figure>
<p>如果要深入思考每一次函数调用中，this 值的变化(更重要的是怎样变化)，你可以阅读本系列教程第 10 章 This。上文所提及的情况都会在此章内详细讨论。</p>
<h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结(Conclusion)"></a>总结(Conclusion)</h2><p>在此我们完成了一个简短的概述。尽管看来不是那么简短，但是这些话题若要完整表述完毕，则需要一整本书。我们没有提及两个重要话题：函数(functions) (以及不同类型的函数之间的不同，比如函数声明与函数表达式)与 ECMAScript 的 求值策略(evaluation strategy) 。这两个话题可以分别查阅本系列教程第 15 章函数(Functions) 与第 19 章求值策略(Evaluation strategy)。</p>
<h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/02/12/深入理解javascript/3全面解析 Module 模式/" class="prev">PREV</a><a href="/2016/01/16/深入理解javascript/2揭秘命名函数表达式/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>