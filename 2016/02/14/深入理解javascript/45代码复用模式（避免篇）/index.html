<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 代码复用模式（避免篇） · xuhongbo</title><meta name="description" content="代码复用模式（避免篇） - xuhongbo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xuhongbo.com/atom.xml" title="xuhongbo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/idea.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">代码复用模式（避免篇）</h1><div class="post-info">Feb 14, 2016</div><div class="post-content"><p>任何编程都提出代码复用，否则话每次开发一个新程序或者写一个新功能都要全新编写的话，那就歇菜了，但是代码复用也是有好要坏，接下来的两篇文章我们将针对代码复用来进行讨论，第一篇文避免篇，指的是要尽量避免使用这些模式，因为或多或少有带来一些问题；第二排是推荐篇，指的是推荐大家使用的模式，一般不会有什么问题。<br><a id="more"></a></p>
<h2 id="模式-1：默认模式"><a href="#模式-1：默认模式" class="headerlink" title="模式 1：默认模式"></a>模式 1：默认模式</h2><p>代码复用大家常用的默认模式，往往是有问题的，该模式使用 Parent()的构造函数创建一个对象，并且将该对象赋值给 Child()的原型。我们看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function inherit(C, P) &#123;</div><div class="line">    C.prototype = new P();</div><div class="line">&#125;</div><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数为空</div><div class="line">function Child(name) &#123;</div><div class="line">&#125;</div><div class="line">// 执行继承</div><div class="line">inherit(Child, Parent);</div><div class="line">var kid = new Child();</div><div class="line">console.log(kid.say()); // &quot;Adam&quot;</div><div class="line">var kiddo = new Child();</div><div class="line">kiddo.name = &quot;Patrick&quot;;</div><div class="line">console.log(kiddo.say()); // &quot;Patrick&quot;</div><div class="line">// 缺点:不能让参数传进给Child构造函数</div><div class="line">var s = new Child(&apos;Seth&apos;);</div><div class="line">console.log(s.say()); // &quot;Adam&quot;</div></pre></td></tr></table></figure>
<p>这种模式的缺点是 Child 不能传进参数，基本上也就废了。</p>
<h2 id="模式-2：借用构造函数"><a href="#模式-2：借用构造函数" class="headerlink" title="模式 2：借用构造函数"></a>模式 2：借用构造函数</h2><p>该模式是 Child 借用 Parent 的构造函数进行 apply，然后将 child 的 this 和参数传递给 apply 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">    Parent.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">var kid = new Child(&quot;Patrick&quot;);</div><div class="line">console.log(kid.name); // &quot;Patrick&quot;</div><div class="line">// 缺点：没有从构造函数上继承say方法</div><div class="line">console.log(typeof kid.say); // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<p>缺点也很明显，say 方法不可用，因为没有继承过来。</p>
<h2 id="模式-3：借用构造函数并设置原型"><a href="#模式-3：借用构造函数并设置原型" class="headerlink" title="模式 3：借用构造函数并设置原型"></a>模式 3：借用构造函数并设置原型</h2><p>上述两个模式都有自己的缺点，那如何把两者的缺点去除呢，我们来尝试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">    Parent.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent();</div><div class="line">var kid = new Child(&quot;Patrick&quot;);</div><div class="line">console.log(kid.name); // &quot;Patrick&quot;</div><div class="line">console.log(typeof kid.say); // function</div><div class="line">console.log(kid.say()); // Patrick</div><div class="line">console.dir(kid);</div><div class="line">delete kid.name;</div><div class="line">console.log(kid.say()); // &quot;Adam&quot;</div></pre></td></tr></table></figure>
<p>运行起来，一切正常，但是有没有发现，Parent 构造函数执行了两次，所以说，虽然程序可用，但是效率很低。</p>
<h2 id="模式4：共享原型"><a href="#模式4：共享原型" class="headerlink" title="模式4：共享原型"></a>模式4：共享原型</h2><p>共享原型是指 Child 和 Parent 使用同样的原型，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function inherit(C, P) &#123;</div><div class="line">    C.prototype = P.prototype;</div><div class="line">&#125;</div><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">&#125;</div><div class="line">inherit(Child, Parent);</div><div class="line">var kid = new Child(&apos;Patrick&apos;);</div><div class="line">console.log(kid.name); // undefined</div><div class="line">console.log(typeof kid.say); // function</div><div class="line">kid.name = &apos;Patrick&apos;;</div><div class="line">console.log(kid.say()); // Patrick</div><div class="line">console.dir(kid);</div></pre></td></tr></table></figure>
<p>确定还是一样，Child 的参数没有正确接收到。</p>
<h2 id="模式-5：临时构造函数"><a href="#模式-5：临时构造函数" class="headerlink" title="模式 5：临时构造函数"></a>模式 5：临时构造函数</h2><p>首先借用构造函数，然后将 Child 的原型设置为该借用构造函数的实例，最后恢复 Child 原型的构造函数。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/* 闭包 */</div><div class="line">var inherit = (function () &#123;</div><div class="line">    var F = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    return function (C, P) &#123;</div><div class="line">        F.prototype = P.prototype;</div><div class="line">        C.prototype = new F();</div><div class="line">        C.uber = P.prototype;</div><div class="line">        C.prototype.constructor = C;</div><div class="line">    &#125;</div><div class="line">&#125; ());</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">&#125;</div><div class="line">inherit(Child, Parent);</div><div class="line">var kid = new Child();</div><div class="line">console.log(kid.name); // undefined</div><div class="line">console.log(typeof kid.say); // function</div><div class="line">kid.name = &apos;Patrick&apos;;</div><div class="line">console.log(kid.say()); // Patrick</div><div class="line">var kid2 = new Child(&quot;Tom&quot;);</div><div class="line">console.log(kid.say()); </div><div class="line">console.log(kid.constructor.name); // Child</div><div class="line">console.log(kid.constructor === Parent); // false</div></pre></td></tr></table></figure>
<p>问题照旧，Child 不能正常接收参数。</p>
<h2 id="模式-6：klass"><a href="#模式-6：klass" class="headerlink" title="模式 6：klass"></a>模式 6：klass</h2><p>这个模式，先上代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">var klass = function (Parent, props) &#123;</div><div class="line">    var Child, F, i;  </div><div class="line">    // 1.</div><div class="line">    // 新构造函数</div><div class="line">    Child = function () &#123;</div><div class="line">        if (Child.uber &amp;&amp; Child.uber.hasOwnProperty(&quot;__construct&quot;)) &#123;</div><div class="line">            Child.uber.__construct.apply(this, arguments);</div><div class="line">        &#125;</div><div class="line">        if (Child.prototype.hasOwnProperty(&quot;__construct&quot;)) &#123;</div><div class="line">            Child.prototype.__construct.apply(this, arguments);</div><div class="line">        &#125;</div><div class="line">    &#125;;  </div><div class="line">    // 2.</div><div class="line">    // 继承</div><div class="line">    Parent = Parent || Object;</div><div class="line">    F = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    F.prototype = Parent.prototype;</div><div class="line">    Child.prototype = new F();</div><div class="line">    Child.uber = Parent.prototype;</div><div class="line">    Child.prototype.constructor = Child;  </div><div class="line">    // 3.</div><div class="line">    // 添加实现方法</div><div class="line">    for (i in props) &#123;</div><div class="line">        if (props.hasOwnProperty(i)) &#123;</div><div class="line">            Child.prototype[i] = props[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // return the &quot;class&quot;</div><div class="line">    return Child;</div><div class="line">&#125;;  </div><div class="line">var Man = klass(null, &#123;</div><div class="line">    __construct: function (what) &#123;</div><div class="line">        console.log(&quot;Man&apos;s constructor&quot;);</div><div class="line">        this.name = what;</div><div class="line">    &#125;,</div><div class="line">    getName: function () &#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;);  </div><div class="line">var first = new Man(&apos;Adam&apos;); // logs &quot;Man&apos;s constructor&quot;</div><div class="line">first.getName(); // &quot;Adam&quot;</div><div class="line">var SuperMan = klass(Man, &#123;</div><div class="line">    __construct: function (what) &#123;</div><div class="line">        console.log(&quot;SuperMan&apos;s constructor&quot;);</div><div class="line">    &#125;,</div><div class="line">    getName: function () &#123;</div><div class="line">        var name = SuperMan.uber.getName.call(this);</div><div class="line">        return &quot;I am &quot; + name;</div><div class="line">    &#125;</div><div class="line">&#125;);  </div><div class="line">var clark = new SuperMan(&apos;Clark Kent&apos;);</div><div class="line">clark.getName(); // &quot;I am Clark Kent&quot;  </div><div class="line">console.log(clark instanceof Man); // true</div><div class="line">console.log(clark instanceof SuperMan); // true</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上六个模式虽然在某种特殊情况下实现了某些功能，但是都存在各自的缺点，所以一般情况，大家要避免使用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/02/25/深入理解javascript/15函数（Functions）/" class="prev">上一篇</a><a href="/2016/02/13/深入理解javascript/5强大的原型和原型链/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>