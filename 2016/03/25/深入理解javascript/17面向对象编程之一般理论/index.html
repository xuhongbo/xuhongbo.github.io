<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 面向对象编程之一般理论 · xuhongbo</title><meta name="description" content="面向对象编程之一般理论 - xuhongbo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xuhongbo.com/atom.xml" title="xuhongbo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">面向对象编程之一般理论</h1><div class="post-info">Mar 25, 2016</div><div class="post-content"><p>在本篇文章，我们考虑在 ECMAScript 中的面向对象编程的各个方面（虽然以前在许多文章中已经讨论过这个话题）。我们将更多地从理论方面看这些问题。 特别是，我们会考虑对象的创建算法，对象（包括基本关系 - 继承）之间的关系是如何，也可以在讨论中使用（我希望将消除之前对于 JavaScript 中 OOP 的一些概念歧义）。<br><a id="more"></a></p>
<h2 id="概论、范式与思想"><a href="#概论、范式与思想" class="headerlink" title="概论、范式与思想"></a>概论、范式与思想</h2><p>在进行 ECMAScript 中的 OOP 技术分析之前，我们有必要掌握一些 OOP 基本的特征，并澄清概论中的主要概念。</p>
<p>ECMAScript 支持包括结构化、面向对象、函数式、命令式等多种编程方式，某些情况下还支持面向方面编程；但本文是讨论面向对象编程，所以来给出 ECMAScript 中面向对象编程的定义:</p>
<blockquote>
<p>ECMAScript 是基于原型实现的面向对象编程语言。</p>
</blockquote>
<p>基于原型的 OOP 和基于静态类的方式直接有很多差异。 让我们一起来看看他们直接详细的差异。</p>
<h2 id="基于类特性和基于原型"><a href="#基于类特性和基于原型" class="headerlink" title="基于类特性和基于原型"></a>基于类特性和基于原型</h2><p>注意，在前面一句很重要的一点已经指出的那样-完全基于静态类。 随着“静态”一词，我们了解静态对象和静态类，强类型（虽然不是必需的）。</p>
<p>关于这种情况，很多论坛上的文档都有强调这是他们反对将在 JavaScript 里将“类与原型”进行比较的主要原因，尽管他们在实现上的有所不同（例如基于动态类的 Python 和 Ruby）不是太反对的重点（某些条件写，尽管思想上有一定不同，但 JavaScript 没有变得那么另类），但他们反对的重点是静态类和动态原型(statics + classes vs. dynamics + prototypes)，确切地说，一个静态类（例如：C++，JAVA）和他的属下及方法定义的机制可以让我们看到它和基于原型实现的准确区别。</p>
<p>但是，让我们来一个一个列举一下。 让我们考虑总则和这些范式的主要概念。</p>
<h2 id="基于静态类"><a href="#基于静态类" class="headerlink" title="基于静态类"></a>基于静态类</h2><p>在基于类的模型中，有个关于类和实例的概念。 类的实例也常常被命名为对象或范例 。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>类代表了一个实例（也就是对象）的抽象。在这方面有点像数学，但我们一把称之为类型（type）或分类（classification）。</p>
<p>例如（这里和下面的例子都是伪代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C = Class &#123;a, b, c&#125; // 类C, 包括特性a, b, c</div></pre></td></tr></table></figure>
<p>实例的特点是：属性（对象描述 ）和方法（对象活动）。特性本身也可视为对象：即属性是否可写的，可配置，可设置的（getter/setter）等。因此，对象存储了状态 （即在一个类中描述的所有属性的具体值），类为他们的实例定义了严格不变的结构（属性）和严格不变的行为（方法）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C = Class &#123;a, b, c, method1, method2&#125;</div><div class="line">c1 = &#123;a: 10, b: 20, c: 30&#125; // 类C是实例：对象с1</div><div class="line">c2 = &#123;a: 50, b: 60, c: 70&#125; // 类C是实例：对象с2，拥有自己的状态（也就是属性值）</div></pre></td></tr></table></figure>
<h3 id="层次继承"><a href="#层次继承" class="headerlink" title="层次继承"></a>层次继承</h3><p>为了提高代码重用，类可以从一个扩展为另一个，在加上额外的信息。 这种机制被称为（分层）继承 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D = Class extends C = &#123;d, e&#125; // &#123;a, b, c, d, e&#125;</div><div class="line">d1 = &#123;a: 10, b: 20, c: 30, d: 40, e: 50&#125;</div></pre></td></tr></table></figure>
<p>在类的实例上调用方的时候，通常会现在原生类本书就查找该方法，如果没找到就到直接父类去查找，如果还没找到，就到父类的父类去查找（例如严格的继承链上），如果查到继承的顶部还没查到，那结果就是：该对象没有类似的行为，也没办法获取结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d1.method1() // D.method1 (no) -&gt; C.method1 (yes)</div><div class="line">d1.method5() // D.method5 (no) -&gt; C.method5 (no) -&gt; no result</div></pre></td></tr></table></figure>
<p>与在继承里方法不复制到一个子类相比，属性总是被复杂到子类里的。 我们可以看到子类D继承自父类C类：属性a，b，c是复制过去了，D 的结构是{a, b, c, d, e} } 。然而，方法{method1, method2}是没有复制过去，而是继承过去的。 因此，也就是说如果一个很深层次的类有一些对象根本不需要的属性的话，那子类也拥有这些属性。</p>
<h3 id="基于类的关键概念"><a href="#基于类的关键概念" class="headerlink" title="基于类的关键概念"></a>基于类的关键概念</h3><p>因此，我们有如下关键概念：</p>
<ol>
<li>创建一个对象之前，必须声明类，首先有必要界定其类；</li>
<li>因此，该对象将由抽象成自身“象形和相似性”（结构和行为）的类里创建；</li>
<li>方法是通过了严格的，直接的，一成不变的继承链来处理；</li>
<li>子类包含了继承链中所有的属性（即使其中的某些属性是子类不需要的）；</li>
<li>创建类实例，类不能（因为静态模型）来改变其实例的特征（属性或方法）；</li>
<li>实例（因为严格的静态模型）除了有该实例所对应类里声明的行为和属性以外，是不能额外的行为或属性的。</li>
</ol>
<p>让我们看看在 JavaScript 里如何替代 OOP 模型，也就是我们所建议的基于原型的 OOP。</p>
<h3 id="基于原型"><a href="#基于原型" class="headerlink" title="基于原型"></a>基于原型</h3><p>这里的基本概念是动态可变对象。转换（完整转换，不仅包括值，还包括特性）和动态语言有直接关系。下面这样的对象可以独立存储他们所有的特性（属性，方法）而不需要的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">object = &#123;a: 10, b: 20, c: 30, method: fn&#125;;</div><div class="line">object.a; // 10</div><div class="line">object.c; // 30</div><div class="line">object.method();</div></pre></td></tr></table></figure>
<p>此外，由于动态的，他们可以很容易地改变（添加，删除，修改）自己的特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">object.method5 = function () &#123;...&#125;; // 添加新方法</div><div class="line">object.d = 40; // 添加新属性 &quot;d&quot;</div><div class="line">delete object.c; // 删除属性 &quot;с&quot;</div><div class="line">object.a = 100; // 修改属性 &quot;а&quot;</div><div class="line">// 结果是: object: &#123;a: 100, b: 20, d: 40, method: fn, method5: fn&#125;;</div></pre></td></tr></table></figure>
<p>也就是说，在赋值的时候，如果某些特性不存在，则创建它并且将赋值与它进行初始化，如果它存在，就只是更新。</p>
<p>在这种情况下，代码重用不是通过扩展类来实现的，（请注意，我们没有说类没办法改变，因为这里根本没有类的概念），而是通过原型来实现的。</p>
<p>原型是一个对象，它是用来作为其他对象的原始 copy，或者如果一些对象没有自己的必要特性，原型可以作为这些对象的一个委托而当成辅助对象。</p>
<h3 id="基于委托"><a href="#基于委托" class="headerlink" title="基于委托"></a>基于委托</h3><p>任何对象都可以被用来作为另一个对象的原型对象，因为对象可以很容易地在运行时改变它的原型动态。</p>
<p>注意，目前我们正在考虑的是概论而不是具体实现，当我们在 ECMAScript 中讨论具体实现时，我们将看到他们自身的一些特点。</p>
<p>例（伪代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">x = &#123;a: 10, b: 20&#125;;</div><div class="line">y = &#123;a: 40, c: 50&#125;;</div><div class="line">y.[[Prototype]] = x; // x是y的原型 </div><div class="line">y.a; // 40, 自身特性</div><div class="line">y.c; // 50, 也是自身特性</div><div class="line">y.b; // 20 – 从原型中获取: y.b (no) -&gt; y.[[Prototype]].b (yes): 20</div><div class="line">delete y.a; // 删除自身的&quot;а&quot;</div><div class="line">y.a; // 10 – 从原型中获取</div><div class="line">z = &#123;a: 100, e: 50&#125;</div><div class="line">y.[[Prototype]] = z; // 将y的原型修改为z</div><div class="line">y.a; // 100 – 从原型z中获取</div><div class="line">y.e // 50, 也是从从原型z中获取</div><div class="line">z.q = 200 // 添加新属性到原型上</div><div class="line">y.q // 修改也适用于y</div></pre></td></tr></table></figure>
<p>这个例子展示了原型作为辅助对象属性的重要功能和机制，就像是要自己的属性一下，和自身属性相比，这些属性是委托属性。这个机制被称为委托，并且基于它的原型模型是一个委托的原型（或基于委托的原型 ） 。引用的机制在这里称为发送信息到对象上，如果这个对象得不到响应就会委托给原型来查找（要求它尝试响应消息）。</p>
<p>在这种情况下的代码重用被称为基于委托的继承或基于原型的继承。由于任何对象可以当成原型，也就是说原型也可以有自己的原型。 这些原型连接在一起形成一个所谓的原型链。 链也像静态类中分层次的，但是它可以很容易地重新排列，改变层次和结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = &#123;a: 10&#125;</div><div class="line">y = &#123;b: 20&#125;</div><div class="line">y.[[Prototype]] = x</div><div class="line">z = &#123;c: 30&#125;</div><div class="line">z.[[Prototype]] = y</div><div class="line">z.a // 10</div><div class="line">// z.a 在原型链里查到:</div><div class="line">// z.a (no) -&gt;</div><div class="line">// z.[[Prototype]].a (no) -&gt;</div><div class="line">// z.[[Prototype]].[[Prototype]].a (yes): 10</div></pre></td></tr></table></figure>
<p>如果一个对象和它的原型链不能响应消息发送，该对象可以激活相应的系统信号，可能是由原型链上其它的委托进行处理。</p>
<p>该系统信号，在许多实现里都是可用的，包括基于括动态类的系统：Smalltalk中的 ＃doesNotUnderstand，Ruby 中的​​ method_missing；Python 中的<strong>getattr</strong>，PHP 中的<strong>call；和 ECMAScript 中的</strong>noSuchMethod__实现，等等。</p>
<p>例（SpiderMonkey 的 ECMAScript 的实现）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var object = &#123;</div><div class="line">  // catch住不能响应消息的系统信号</div><div class="line">  __noSuchMethod__: function (name, args) &#123;</div><div class="line">    alert([name, args]);</div><div class="line">    if (name == &apos;test&apos;) &#123;</div><div class="line">      return &apos;.test() method is handled&apos;;</div><div class="line">    &#125;</div><div class="line">    return delegate[name].apply(this, args);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var delegate = &#123;</div><div class="line">  square: function (a) &#123;</div><div class="line">    return a * a;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">alert(object.square(10)); // 100</div><div class="line">alert(object.test()); // .test() method is handled</div></pre></td></tr></table></figure>
<p>也就是说，基于静态类的实现，在不能响应消息的情况下，得出的结论是：目前的对象不具有所要求的特性，但是如果尝试从原型链里获取，依然可能得到结果，或者该对象经过一系列变化以后拥有该特性。</p>
<p>关于 ECMAScript，具体的实现就是：使用基于委托的原型。 然而，正如我们将从规范和实现里看到的，他们也有自身的特性。</p>
<h3 id="Concatenative模型"><a href="#Concatenative模型" class="headerlink" title="Concatenative模型"></a>Concatenative模型</h3><p>老实说，有必要在说句话关于另外一种情况（尽快在 ECMASCript 没有用到）：当原型从其它对象复杂原来代替原生对象这种情况。这种情况代码重用是在对象创建阶段对一个对象的真正复制（克隆）而不是委托。这种原型被称为 concatenative 原型。复制对象所有原型的特性，可以进一步完全改变其属性和方法,同样作为原型可以改变自己（在基于委托的模型中，这个改变不会改变现有存在的对象行为，而是改变它的原型特性）。 这种方法的优点是可以减少调度和委托的时间，而缺点是内存使用率搞。</p>
<h3 id="Duck类型"><a href="#Duck类型" class="headerlink" title="Duck类型"></a>Duck类型</h3><p>回来动态弱类型变化的对象，与基于静态类的模型相比，检验它是否可以做这些事和对象有什么类型（类）无关，而是是否能够相应消息有关（即在检查以后是否有能力做它是必须的） 。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 在基于静态来的模型里</div><div class="line">if (object instanceof SomeClass) &#123;</div><div class="line">  // 一些行为是运行的</div><div class="line">&#125;</div><div class="line">// 在动态实现里</div><div class="line">// 对象在此时是什么类型并不重要</div><div class="line">// 因为突变、类型、特性可以自由重复的转变。</div><div class="line">// 重要的对象是否可以响应test消息 </div><div class="line">if (isFunction(object.test)) // ECMAScript</div><div class="line">if object.respond_to?(:test) // Ruby</div><div class="line">if hasattr(object, &apos;test&apos;): // Python</div></pre></td></tr></table></figure>
<p>这就是所谓的 Dock类型。 也就是说，物体在 check 的时候可以通过自己的特性来识别，而不是对象在层次结构中的位置或他们属于任何具体类型。</p>
<h3 id="基于原型的关键概念"><a href="#基于原型的关键概念" class="headerlink" title="基于原型的关键概念"></a>基于原型的关键概念</h3><p>让我们来看一下这种方式的主要特点：</p>
<ol>
<li>基本概念是对象</li>
<li>对象是完全动态可变的（理论上完全可以从一个类型转化到另一个类型）</li>
<li>对象没有描述自己的结构和行为的严格类，对象不需要类</li>
<li>对象没有类类但可以可以有原型，他们如果不能响应消息的话可以委托给原型</li>
<li>在运行时随时可以改变对象的原型;</li>
<li>在基于委托的模型中，改变原型的特点，将影响到与该原型相关的所有对象;</li>
<li>在 concatenative 原型模型中，原型是从其他对象克隆的原始副本，并进一步成为完全独立的副本原件，原型特性的变换不会影响从它克隆的对象</li>
<li>如果不能响应消息，它的调用者可以采取额外的措施（例如，改变调度）</li>
<li>对象的失败可以不由它们的层次和所属哪个类来决定，而是由当前特性来决定</li>
</ol>
<p>不过，还有一个模型，我们也应该考虑。</p>
<h3 id="基于动态类"><a href="#基于动态类" class="headerlink" title="基于动态类"></a>基于动态类</h3><p>我们认为，在上面例子里展示的区别“类 VS 原型 ”在这个基于动态类的模型中不是那么重要，（尤其是如果原型链是不变的，为更准确区分，还是有必要考虑一个静态类）。 作为例子，它也可以使用 Python 或 Ruby（或其他类似的语言）。 这些语言都使用基于动态类的范式。 然而，在某些方面，我们是可以看到基于原型实现的某些功能。</p>
<p>在下面例子中，我们可以看到仅仅是基于委托的原型，我们可以放大一个类（原型），从而影响到所有与这个类相关的对象，我们也可以在运行时动态地改变这个对象的类（为委托提供一个新对象）等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">\# Python</div><div class="line">class A(object):</div><div class="line">    def __init__(self, a):</div><div class="line">        self.a = a</div><div class="line">    def square(self):</div><div class="line">        return self.a * self.a</div><div class="line">a = A(10) # 创建实例</div><div class="line">print(a.a) # 10</div><div class="line">A.b = 20 # 为类提供一个新属性</div><div class="line">print(a.b) # 20 – 可以在&quot;a&quot;实例里访问到</div><div class="line">a.b = 30 # 创建a自身的属性</div><div class="line">print(a.b) # 30</div><div class="line">del a.b # 删除自身的属性</div><div class="line">print(a.b) # 20 - 再次从类里获取（原型）</div><div class="line">\# 就像基于原型的模型</div><div class="line">\# 可以在运行时改变对象的原型</div><div class="line">class B(object): # 空类B</div><div class="line">    pass</div><div class="line">b = B() # B的实例</div><div class="line">b.__class__ = A # 动态改变类（原型）</div><div class="line">b.a = 10 # 创建新属性</div><div class="line">print(b.square()) # 100 - A类的方法这时候可用</div><div class="line">\# 可以显示删除类上的引用</div><div class="line">del A</div><div class="line">del B</div><div class="line">\# 但对象依然有隐式的引用，并且这些方法依然可用</div><div class="line">print(b.square()) # 100</div><div class="line">\# 但这时候不能再改变类了</div><div class="line">\# 这是实现的特性</div><div class="line">b.__class__ = dict # error</div></pre></td></tr></table></figure>
<p>Ruby 中的实现也是类似的：也使用了完全动态的类（顺便说一下在当前版本的 Python 中，与 Ruby 和 ECMAScript 的对比，放大类（原型）不行的），我们可以彻底改变对象（或类）的特性（在类上添加方法/属性，而这些变化会影响已经存在的对象），但是，它不能的动态改变一个对象的类。</p>
<p>但是，这篇文章不是专门针对 Python 和 Ruby 的，因此我们不多说了，我们来继续讨论 ECMAScript 本身。</p>
<p>但在此之前，我们还得再看一下在一些 OOP 里有的“语法糖”，因为很多之前关于 JavaScript 的文章往往会文这些问题。</p>
<p>本节唯一需要注意的错误句子是：“JavaScript不是类，它有原型，可以代替类”。 非常有必要知道并非所有基于类的实现都是完全不一样的,即便我们可能会说“JavaScript是不同的”，但也有必要考虑（除了“类”的概念）还有其他相关的特性呢。</p>
<h2 id="各种-OOP-实现的其它特性"><a href="#各种-OOP-实现的其它特性" class="headerlink" title="各种 OOP 实现的其它特性"></a>各种 OOP 实现的其它特性</h2><p>本节我们简要介绍一下其它特性和各种 OOP 实现中关于代码重用的方式，也包括 ECMAScript 中的 OOP 实现。 原因是，之前出现的关于 JavaScript 中关于 OOP 的实现是有一些习惯性的思维限制，唯一主要的要求是，应该在技术上和思想上加以证明。不能说没发现和其它 OOP 实现里的语法糖功能，就草率认为 JavaScript 不是不是纯粹的 OOP 语言，这是不对滴。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在 ECMAScript 中对象有几种含义的多态性。</p>
<p>例如，一个函数可以应用于不同的对象，就像原生对象的特性（因为这个值在进入执行上下文时确定的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">  alert([this.a, this.b]);</div><div class="line">&#125;</div><div class="line">test.call(&#123;a: 10, b: 20&#125;); // 10, 20</div><div class="line">test.call(&#123;a: 100, b: 200&#125;); // 100, 200</div><div class="line">var a = 1;</div><div class="line">var b = 2;</div><div class="line">test(); // 1, 2</div></pre></td></tr></table></figure>
<p>不过，也有例外：Date.prototype.getTime()方法，根据标准这个值总是应该有一个日期对象，否则就会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Date.prototype.getTime.call(new Date())); // time</div><div class="line">alert(Date.prototype.getTime.call(new String(&apos;&apos;))); // TypeError</div></pre></td></tr></table></figure>
<p>所谓函数定义时的参数多态性也就等价于所有数据类型，只不过接受多态性参数（例如数组的 .sort 排序方法和它的参数——多态的排序功能）。顺便说一下，上面的例子也可以被视为是一种参数多态性。</p>
<p>原型里方法可以被定义为空，所有创建的对象应重新定义（实现）该方法（即“一个接口（签名），多个实现”）。</p>
<p>多态性和我们上面提到的Duck类型是有关的：即对象的类型和在层次结构中的位置不是那么重要，但如果它有所有必要的特征，它可以很容易地接受（即通用接口很重要，实现则可以多种多样）。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>关于封装，往往会有错误的看法。本节我们讨论一下一些 OOP 实现里的语法糖——也就是众所周知的修饰符：在这种情况下，我们将讨论一些OOP实现便捷的“糖” -众所周知的修饰符：private，protected 和 public（或者称为对象的访问级别或访问修饰符）。</p>
<p>在这里我要提醒一下封装的主要目的：封装是一个抽象的增加，而不是选拔个直接往你的类里写入一些东西的隐藏“恶意黑客”。</p>
<p>这是一个很大的错误：为了隐藏使用隐藏。</p>
<p>访问级别（private，protected 和 public），为了方便编程在很多面向对象里都已经实现了（真的是非常方便的语法糖），更抽象地描述和构建系统。</p>
<p>这些可以在一些实现里看出（如已经提到的Python和Ruby）。一方面（在 Python 中），这些<strong>private _protected 属性（通过下划线这个命名规范），从外部不可访问。 另一方面，Python 可以通过特殊的规则从外部访问（_ClassName</strong>field_name）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class A(object):</div><div class="line">    def __init__(self):</div><div class="line">      self.public = 10</div><div class="line">      self.__private = 20</div><div class="line">    def get_private(self):</div><div class="line">        return self.__private</div><div class="line">\# outside:</div><div class="line">a = A() # A的实例</div><div class="line">print(a.public) # OK, 30</div><div class="line">print(a.get_private()) # OK, 20</div><div class="line">print(a.__private) # 失败，因为只能在A里可用</div><div class="line">\# 但在Python里，可以通过特殊规则来访问</div><div class="line">print(a._A__private) # OK, 20</div></pre></td></tr></table></figure>
<p>在 Ruby 里：一方面有能力来定义 private 和 protected 的特性，另一方面，也有特殊的方法（ 例如 instance_variable_get，instance_variable_set，send 等）获取封装的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">  def initialize</div><div class="line">    @a = 10</div><div class="line">  end</div><div class="line">  def public_method</div><div class="line">    private_method(20)</div><div class="line">  end</div><div class="line">private</div><div class="line">  def private_method(b)</div><div class="line">    return @a + b</div><div class="line">  end</div><div class="line">end</div><div class="line">a = A.new # 新实例</div><div class="line">a.public_method # OK, 30</div><div class="line">a.a # 失败, @a - 是私有的实例变量</div><div class="line">\# &quot;private_method&quot;是私有的，只能在A类里访问</div><div class="line">a.private_method # 错误</div><div class="line">\# 但是有特殊的元数据方法名，可以获取到数据</div><div class="line">a.send(:private_method, 20) # OK, 30</div><div class="line">a.instance_variable_get(:@a) # OK, 10</div></pre></td></tr></table></figure>
<p>最主要的原因是，程序员自己想要获得的封装（请注意，我特别不使用“隐藏”）的数据。 如果这些数据会以某种方式不正确地更改或有任何错误,则全部责任都是程序员，但不是简单的“拼写错误”或“随便改变某些字段”。 但如果这种情况很频繁，那就是很不好的编程习惯和风格 ，因为通常值用公共的 API 来和对象“交谈”。</p>
<p>重复一下，封装的基本目的是一个从辅助数据的用户中抽象出来，而不是一个防止黑客隐藏数据。 更严重的，封装不是用 private 修饰数据而达到软件安全的目的。</p>
<p>封装辅助对象（局部），我们用最小的代价、本地化和预测性变化来问为公共接口的行为变化提供可行性，这也正是封装的目的。</p>
<p>另外 setter 方法​​的重要目的是抽象复杂的计算。 例如，element.innerHTML 这个 setter ——抽象的语句——“现在这个元素内的 HTML 是如下内容”，而在 innerHTML 属性的 setter 函数将难以计算和检查。 在这种情况下，问题大多涉及到抽象 ，但封装也会发生。</p>
<p>封装的概念不仅仅只与 OOP 相关。 例如，它可以是一个简单的功能，只封装了各种计算，使得其抽象（没有必要让用户知道，例如函数 Math.round（… …）是如何实现的，用户只是简单地调用它）。 它是一种封装，注意，我没有说他是“private, protected 和 public”。</p>
<p>ECMAScript 规范的当前版本，没有定义 private，protected 和 public 修饰符。</p>
<p>然而，在实践中是有可能看到有些东西被命名为“模仿 JS 封装”。 一般该上下文的目的是（作为一个规则，构造函数本身）使用。 不幸的是，经常实施这种“模仿”，程序员可以产生伪绝对非抽象的实体设置“getter/setter方法”（我再说一遍，它是错误的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">  var _a; // &quot;private&quot; a</div><div class="line">  this.getA = function _getA() &#123;</div><div class="line">    return _a;</div><div class="line">  &#125;;</div><div class="line">  this.setA = function _setA(a) &#123;</div><div class="line">    _a = a;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">var a = new A();</div><div class="line">a.setA(10);</div><div class="line">alert(a._a); // undefined, &quot;private&quot;</div><div class="line">alert(a.getA()); // 10</div></pre></td></tr></table></figure>
<p>因此，每个人都明白，对于每个创建的对象，对于的 getA/setA 方法也创建了，这也是导致内存增加的原因（和原型定义相比）。 虽然，理论上第一种情况下可以对对象进行优化。</p>
<p>另外，一些 JavaScript 的文章经常提到“私有方法”的概念，注意：ECMA-262-3 标准里没有定义任何关于“私有方法”的概念。</p>
<p>但是，某些情况下它可以在构造函数中创建，因为JS是意识形态的语言——对象是完全可变的并且有独特的特性（在构造函数里某些条件下，有些对象可以得到额外的方法，而其他则不行）。</p>
<p>此外，在 JavaScript 里，如果还是把封装曲解成为了不让恶意黑客在某些自动写入某些值的一种理解来代替使用 setter 方法，那所谓的“隐藏(hidden)”和“私有(private)”其实没有很“隐藏”，，有些实现可以通过调用上下文到 eval 函数（可以在 SpiderMonkey1.7 上测试）在相关的作用域链（以及相应的所有变量对象）上获取值）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eval(&apos;_a = 100&apos;, a.getA); // 或者a.setA,因为&quot;_a&quot;两个方法的[[Scope]]上</div><div class="line">a.getA(); // 100</div></pre></td></tr></table></figure>
<p>或者，在实现中允许直接进入活动对象（例如 Rhino），通过访问该对象的相应属性可以改变内部变量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Rhino</div><div class="line">var foo = (function () &#123;</div><div class="line">  var x = 10; // &quot;private&quot;</div><div class="line">  return function () &#123;</div><div class="line">    print(x);</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line">foo(); // 10</div><div class="line">foo.__parent__.x = 20;</div><div class="line">foo(); // 20</div></pre></td></tr></table></figure>
<p>有时，在 JavaScript 里通过在变量前加下划线来达到“private”和“protected”数据的目的（但与 Python 相比，这里只是命名规范）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var _myPrivateData = &apos;testString&apos;;</div></pre></td></tr></table></figure>
<p>对于括号括住执行上下文是经常使用，但对于真正的辅助数据，则和对象没有直接关联，只是方便从外部的 API 抽象出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">  // 初始化上下文</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>多继承是代码重用改进的一个很方便的语法糖（如果我们一次能继承一个类，为什么不能一次继承 10 个？）。 然而由于多重继承有一些不足，才导致在实现中没有流行起来。</p>
<p>ECMAScript 不支持多继承（即只有一个对象，可以用来作为一个直接原型），虽然其祖先自编程语言有这样的能力。 但在某些实现中(如 SpiderMonkey)使用<strong>noSuchMethod</strong>可以用于管理调度和委托来替代原型链。</p>
<h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p>Mixins 是代码重用的一种便捷方式。 Mixins 已建议作为多重继承的替代品。 这些独立的元素都可以与任何对象进行混合来扩展它们的功能（因此对象也可以混合多个 Mixins）。 ECMA-262-3 规范没有定义“Mixins”的概念，但根据 Mixins 定义以及 ECMAScript 拥有动态可变对象，所以使用 Mixins 简单地扩充特性是没有障碍的。</p>
<p>典型的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// helper for augmentation</div><div class="line">Object.extend = function (destination, source) &#123;</div><div class="line">  for (property in source) if (source.hasOwnProperty(property)) &#123;</div><div class="line">    destination[property] = source[property];</div><div class="line">  &#125;</div><div class="line">  return destination;</div><div class="line">&#125;;</div><div class="line">var X = &#123;a: 10, b: 20&#125;;</div><div class="line">var Y = &#123;c: 30, d: 40&#125;;</div><div class="line">Object.extend(X, Y); // mix Y into X</div><div class="line">alert([X.a, X.b, X.c, X.d]); 10, 20, 30, 40</div></pre></td></tr></table></figure>
<p>请注意，我采取在 ECMA-262-3 中被提及过的引号中的这些定义（“mixin”，“mix”），在规范里并没有这样的概念，而且不是 mix 而是常用的通过新特性去扩展对象。（Ruby 中 mixins 的概念是官方定义的，mixin 创建了一个包含模块的一个引用来代替简单复制该模块的所有属性到另外一个模块上——事实上是：为委托创建一个额外的对象（原型））。</p>
<h3 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h3><p>Traits 和 mixins 的概念相似，但它有很多功能（根据定义，因为可以应用 mixins 所以不能包含状态，因为它有可能导致命名冲突）。 根据 ECMAScript 说明 Traits 和 mixins 遵循同样的原则，所以该规范没有定义“Traits”的概念。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在一些 OOP 中实现的接口和 mixins 及 traits 类似。然而，与 mixins 及 traits 相比，接口强制实现类必须实现其方法签名的行为。</p>
<p>接口完全可以被视为抽象类。不过与抽象类相比（抽象类里的方法可以只实现一部分，另外一部分依然定义为签名），继承只能是单继承基类，但可以继承多个接口，节约这个原因，可以接口（多个混合）可以看做是多继承的替代方案。</p>
<p>ECMA-262-3 标准既没有定义“接口”的概念，也没有定义“抽象类”的概念。 然而，作为模仿，它是可以由“空”的方法（或空方法中抛出异常，告诉开发人员这个方法需要被实现）的对象来实现。</p>
<h3 id="对象组合"><a href="#对象组合" class="headerlink" title="对象组合"></a>对象组合</h3><p>对象组合也是一个动态代码重用技术之一。 对象组合不同于高灵活性的继承，它实现了一个动态可变的委托。而这，也是基于委托原型的基本。 除了动态可变原型，该对象可以为委托聚合对象（创建一个组合作为结果——聚合 ），并进一步发送消息到对象上，委托到该委托上。这可以两个以上的委托，因为它的动态特性决定着它可以在运行时改变。</p>
<p>已经提到的<strong>noSuchMethod</strong>例子是这样，但也让我们展示了如何明确地使用委托：</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var _delegate = &#123;</div><div class="line">  foo: function () &#123;</div><div class="line">    alert(&apos;_delegate.foo&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var agregate = &#123;</div><div class="line">  delegate: _delegate,</div><div class="line">  foo: function () &#123;</div><div class="line">    return this.delegate.foo.call(this);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">agregate.foo(); // delegate.foo</div><div class="line">agregate.delegate = &#123;</div><div class="line">  foo: function () &#123;</div><div class="line">    alert(&apos;foo from new delegate&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">agregate.foo(); // foo from new delegate</div></pre></td></tr></table></figure>
<p>这种对象关系称为“has-a”，而集成是“is-a”的关系。</p>
<p>由于显示组合的缺乏（与继承相比的灵活性），增加中间代码也是可以的。</p>
<h3 id="AOP-特性"><a href="#AOP-特性" class="headerlink" title="AOP 特性"></a>AOP 特性</h3><p>作为面向方面的一个功能，可以使用 function decorators。ECMA-262-3 规格没有明确定义的“function decorators”的概念（和 Python 相对，这个词是在 Python 官方定义了）。 不过，拥有函数式参数的函数在某些方面是可以装饰和激活的（通过应用所谓的建议）：</p>
<p>最简单的装饰者例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function checkDecorator(originalFunction) &#123;</div><div class="line">  return function () &#123;</div><div class="line">    if (fooBar != &apos;test&apos;) &#123;</div><div class="line">      alert(&apos;wrong parameter&apos;);</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line">    return originalFunction();</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">function test() &#123;</div><div class="line">  alert(&apos;test function&apos;);</div><div class="line">&#125;</div><div class="line">var testWithCheck = checkDecorator(test);</div><div class="line">var fooBar = false;</div><div class="line">test(); // &apos;test function&apos;</div><div class="line">testWithCheck(); // &apos;wrong parameter&apos;</div><div class="line">fooBar = &apos;test&apos;;</div><div class="line">test(); // &apos;test function&apos;</div><div class="line">testWithCheck(); // &apos;test function&apos;</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在这篇文章，我们理清了 OOP 的概论（我希望这些资料已经对你有用了），下一章节我们将继续面向对象编程之 ECMAScript 的实现 </p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/05/深入理解javascript/26设计模式之构造函数模式/" class="prev">上一篇</a><a href="/2016/03/25/深入理解javascript/20《你真懂 JavaScript 吗？》答案详解/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>