<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 代码复用模式（推荐篇） · xuhongbo</title><meta name="description" content="代码复用模式（推荐篇） - xuhongbo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xuhongbo.com/atom.xml" title="xuhongbo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">代码复用模式（推荐篇）</h1><div class="post-info">May 29, 2016</div><div class="post-content"><p>本文介绍的四种代码复用模式都是最佳实践，推荐大家在编程的过程中使用。</p>
<h2 id="模式-1：原型继承"><a href="#模式-1：原型继承" class="headerlink" title="模式 1：原型继承"></a>模式 1：原型继承</h2><p>原型继承是让父对象作为子对象的原型，从而达到继承的目的：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">    function F() &#123;</div><div class="line">    &#125;  </div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">&#125;    </div><div class="line">// 要继承的父对象</div><div class="line">var parent = &#123;</div><div class="line">    name: &quot;Papa&quot;</div><div class="line">&#125;;  </div><div class="line">// 新对象</div><div class="line">var child = object(parent);  </div><div class="line">// 测试</div><div class="line">console.log(child.name); // &quot;Papa&quot;  </div><div class="line">// 父构造函数</div><div class="line">function Person() &#123;</div><div class="line">    // an &quot;own&quot; property</div><div class="line">    this.name = &quot;Adam&quot;;</div><div class="line">&#125;</div><div class="line">// 给原型添加新属性</div><div class="line">Person.prototype.getName = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// 创建新person</div><div class="line">var papa = new Person();</div><div class="line">// 继承</div><div class="line">var kid = object(papa);</div><div class="line">console.log(kid.getName()); // &quot;Adam&quot;  </div><div class="line">// 父构造函数</div><div class="line">function Person() &#123;</div><div class="line">    // an &quot;own&quot; property</div><div class="line">    this.name = &quot;Adam&quot;;</div><div class="line">&#125;</div><div class="line">// 给原型添加新属性</div><div class="line">Person.prototype.getName = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// 继承</div><div class="line">var kid = object(Person.prototype);</div><div class="line">console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的</div><div class="line">console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型</div></pre></td></tr></table></figure></p>
<p>同时，ECMAScript5 也提供了类似的一个方法叫做 Object.create 用于继承对象，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* 使用新版的ECMAScript 5提供的功能 */</div><div class="line">var child = Object.create(parent);  </div><div class="line">var child = Object.create(parent, &#123;</div><div class="line">    age: &#123; value: 2&#125; // ECMA5 descriptor</div><div class="line">&#125;);</div><div class="line">console.log(child.hasOwnProperty(&quot;age&quot;)); // true</div></pre></td></tr></table></figure>
<p>而且，也可以更细粒度地在第二个参数上定义属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 首先，定义一个新对象man</div><div class="line">var man = Object.create(null);  </div><div class="line">// 接着，创建包含属性的配置设置</div><div class="line">// 属性设置为可写，可枚举，可配置</div><div class="line">var config = &#123;</div><div class="line">    writable: true,</div><div class="line">    enumerable: true,</div><div class="line">    configurable: true</div><div class="line">&#125;;  </div><div class="line">// 通常使用Object.defineProperty()来添加新属性(ECMAScript5支持）</div><div class="line">// 现在，为了方便，我们自定义一个封装函数</div><div class="line">var defineProp = function (obj, key, value) &#123;</div><div class="line">    config.value = value;</div><div class="line">    Object.defineProperty(obj, key, config);</div><div class="line">&#125;  </div><div class="line">defineProp(man, &apos;car&apos;, &apos;Delorean&apos;);</div><div class="line">defineProp(man, &apos;dob&apos;, &apos;1981&apos;);</div><div class="line">defineProp(man, &apos;beard&apos;, false);</div></pre></td></tr></table></figure>
<p>所以，继承就这么可以做了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var driver = Object.create( man );</div><div class="line">defineProp (driver, &apos;topSpeed&apos;, &apos;100mph&apos;);</div><div class="line">driver.topSpeed // 100mph</div></pre></td></tr></table></figure>
<p>但是有个地方需要注意，就是 Object.create(null)创建的对象的原型为 undefined，也就是没有 toString 和 valueOf 方法，所以 alert(man)；的时候会出错，但 alert(man.car)；是没问题的。</p>
<h2 id="模式-2：复制所有属性进行继承"><a href="#模式-2：复制所有属性进行继承" class="headerlink" title="模式 2：复制所有属性进行继承"></a>模式 2：复制所有属性进行继承</h2><p>这种方式的继承就是将父对象里所有的属性都复制到子对象上，一般子对象可以使用父对象的数据。</p>
<p>先来看一个浅拷贝的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/* 浅拷贝 */</div><div class="line">function extend(parent, child) &#123;</div><div class="line">    var i;</div><div class="line">    child = child || &#123;&#125;;</div><div class="line">    for (i in parent) &#123;</div><div class="line">        if (parent.hasOwnProperty(i)) &#123;</div><div class="line">            child[i] = parent[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;  </div><div class="line">var dad = &#123; name: &quot;Adam&quot; &#125;;</div><div class="line">var kid = extend(dad);</div><div class="line">console.log(kid.name); // &quot;Adam&quot;  </div><div class="line">var dad = &#123;</div><div class="line">    counts: [1, 2, 3],</div><div class="line">    reads: &#123; paper: true &#125;</div><div class="line">&#125;;</div><div class="line">var kid = extend(dad);</div><div class="line">kid.counts.push(4);</div><div class="line">console.log(dad.counts.toString()); // &quot;1,2,3,4&quot;</div><div class="line">console.log(dad.reads === kid.reads); // true</div></pre></td></tr></table></figure>
<p>代码的最后一行，你可以发现 dad 和 kid 的 reads 是一样的，也就是他们使用的是同一个引用，这也就是浅拷贝带来的问题。</p>
<p>我们再来看一下深拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/* 深拷贝 */</div><div class="line">function extendDeep(parent, child) &#123;</div><div class="line">    var i,</div><div class="line">        toStr = Object.prototype.toString,</div><div class="line">        astr = &quot;[object Array]&quot;;  </div><div class="line">    child = child || &#123;&#125;;  </div><div class="line">    for (i in parent) &#123;</div><div class="line">        if (parent.hasOwnProperty(i)) &#123;</div><div class="line">            if (typeof parent[i] === &apos;object&apos;) &#123;</div><div class="line">                child[i] = (toStr.call(parent[i]) === astr) ? [] : &#123;&#125;;</div><div class="line">                extendDeep(parent[i], child[i]);</div><div class="line">            &#125; else &#123;</div><div class="line">                child[i] = parent[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;  </div><div class="line">var dad = &#123;</div><div class="line">    counts: [1, 2, 3],</div><div class="line">    reads: &#123; paper: true &#125;</div><div class="line">&#125;;</div><div class="line">var kid = extendDeep(dad);  </div><div class="line">kid.counts.push(4);</div><div class="line">console.log(kid.counts.toString()); // &quot;1,2,3,4&quot;</div><div class="line">console.log(dad.counts.toString()); // &quot;1,2,3&quot;  </div><div class="line">console.log(dad.reads === kid.reads); // false</div><div class="line">kid.reads.paper = false;</div></pre></td></tr></table></figure>
<p>深拷贝以后，两个值就不相等了，bingo！</p>
<h2 id="模式-3：混合（mix-in）"><a href="#模式-3：混合（mix-in）" class="headerlink" title="模式 3：混合（mix-in）"></a>模式 3：混合（mix-in）</h2><p>混入就是将一个对象的一个或多个（或全部）属性（或方法）复制到另外一个对象，我们举一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function mix() &#123;</div><div class="line">    var arg, prop, child = &#123;&#125;;</div><div class="line">    for (arg = 0; arg &lt; arguments.length; arg += 1) &#123;</div><div class="line">        for (prop in arguments[arg]) &#123;</div><div class="line">            if (arguments[arg].hasOwnProperty(prop)) &#123;</div><div class="line">                child[prop] = arguments[arg][prop];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;  </div><div class="line">var cake = mix(</div><div class="line">                &#123; eggs: 2, large: true &#125;,</div><div class="line">                &#123; butter: 1, salted: true &#125;,</div><div class="line">                &#123; flour: &apos;3 cups&apos; &#125;,</div><div class="line">                &#123; sugar: &apos;sure!&apos; &#125;</div><div class="line">                );  </div><div class="line">console.dir(cake);</div></pre></td></tr></table></figure>
<p>mix 函数将所传入的所有参数的子属性都复制到 child 对象里，以便产生一个新对象。</p>
<p>那如何我们只想混入部分属性呢？该个如何做？其实我们可以使用多余的参数来定义需要混入的属性，例如 mix（child,parent,method1,method2)这样就可以只将 parent 里的 method1 和 method2 混入到 child 里。上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// Car </div><div class="line">var Car = function (settings) &#123;</div><div class="line">    this.model = settings.model || &apos;no model provided&apos;;</div><div class="line">    this.colour = settings.colour || &apos;no colour provided&apos;;</div><div class="line">&#125;;  </div><div class="line">// Mixin</div><div class="line">var Mixin = function () &#123; &#125;;</div><div class="line">Mixin.prototype = &#123;</div><div class="line">    driveForward: function () &#123;</div><div class="line">        console.log(&apos;drive forward&apos;);</div><div class="line">    &#125;,</div><div class="line">    driveBackward: function () &#123;</div><div class="line">        console.log(&apos;drive backward&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;  </div><div class="line">// 定义的2个参数分别是被混入的对象（reciving）和从哪里混入的对象（giving)</div><div class="line">function augment(receivingObj, givingObj) &#123;</div><div class="line">    // 如果提供了指定的方法名称的话，也就是参数多余3个</div><div class="line">    if (arguments[2]) &#123;</div><div class="line">        for (var i = 2, len = arguments.length; i &lt; len; i++) &#123;</div><div class="line">            receivingObj.prototype[arguments[i]] = givingObj.prototype[arguments[i]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 如果不指定第3个参数，或者更多参数，就混入所有的方法</div><div class="line">    else &#123;</div><div class="line">        for (var methodName in givingObj.prototype) &#123;</div><div class="line">            // 检查receiving对象内部不包含要混入的名字，如何包含就不混入了</div><div class="line">            if (!receivingObj.prototype[methodName]) &#123;</div><div class="line">                receivingObj.prototype[methodName] = givingObj.prototype[methodName];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;  </div><div class="line">// 给Car混入属性，但是值混入&apos;driveForward&apos; 和 &apos;driveBackward&apos;*/</div><div class="line">augment(Car, Mixin, &apos;driveForward&apos;, &apos;driveBackward&apos;);  </div><div class="line">// 创建新对象Car</div><div class="line">var vehicle = new Car(&#123; model: &apos;Ford Escort&apos;, colour: &apos;blue&apos; &#125;);  </div><div class="line">// 测试是否成功得到混入的方法</div><div class="line">vehicle.driveForward();</div><div class="line">vehicle.driveBackward();</div></pre></td></tr></table></figure>
<p>该方法使用起来就比较灵活了。</p>
<h2 id="模式-4：借用方法"><a href="#模式-4：借用方法" class="headerlink" title="模式 4：借用方法"></a>模式 4：借用方法</h2><p>一个对象借用另外一个对象的一个或两个方法，而这两个对象之间不会有什么直接联系。不用多解释，直接用代码解释吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">var one = &#123;</div><div class="line">    name: &apos;object&apos;,</div><div class="line">    say: function (greet) &#123;</div><div class="line">        return greet + &apos;, &apos; + this.name;</div><div class="line">    &#125;</div><div class="line">&#125;;  </div><div class="line">// 测试</div><div class="line">console.log(one.say(&apos;hi&apos;)); // &quot;hi, object&quot;  </div><div class="line">var two = &#123;</div><div class="line">    name: &apos;another object&apos;</div><div class="line">&#125;;  </div><div class="line">console.log(one.say.apply(two, [&apos;hello&apos;])); // &quot;hello, another object&quot;  </div><div class="line">// 将say赋值给一个变量，this将指向到全局变量</div><div class="line">var say = one.say;</div><div class="line">console.log(say(&apos;hoho&apos;)); // &quot;hoho, undefined&quot;  </div><div class="line">// 传入一个回调函数callback</div><div class="line">var yetanother = &#123;</div><div class="line">    name: &apos;Yet another object&apos;,</div><div class="line">    method: function (callback) &#123;</div><div class="line">        return callback(&apos;Hola&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(yetanother.method(one.say)); // &quot;Holla, undefined&quot;  </div><div class="line">function bind(o, m) &#123;</div><div class="line">    return function () &#123;</div><div class="line">        return m.apply(o, [].slice.call(arguments));</div><div class="line">    &#125;;</div><div class="line">&#125;  </div><div class="line">var twosay = bind(two, one.say);</div><div class="line">console.log(twosay(&apos;yo&apos;)); // &quot;yo, another object&quot;  </div><div class="line">// ECMAScript 5给Function.prototype添加了一个bind()方法，以便很容易使用apply()和call()。  </div><div class="line">if (typeof Function.prototype.bind === &apos;undefined&apos;) &#123;</div><div class="line">    Function.prototype.bind = function (thisArg) &#123;</div><div class="line">        var fn = this,</div><div class="line">slice = Array.prototype.slice,</div><div class="line">args = slice.call(arguments, 1);</div><div class="line">        return function () &#123;</div><div class="line">            return fn.apply(thisArg, args.concat(slice.call(arguments)));</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;  </div><div class="line">var twosay2 = one.say.bind(two);</div><div class="line">console.log(twosay2(&apos;Bonjour&apos;)); // &quot;Bonjour, another object&quot;  </div><div class="line">var twosay3 = one.say.bind(two, &apos;Enchanté&apos;);</div><div class="line">console.log(twosay3()); // &quot;Enchanté, another object&quot;</div></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2016/06/22/深入理解javascript/13ThisYes,this!/" class="prev">PREV</a><a href="/2016/05/11/深入理解javascript/29设计模式之装饰者模式/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2016/05/29/深入理解javascript/46代码复用模式（推荐篇）/';
var disqus_title = '代码复用模式（推荐篇）';
var disqus_url = 'http://xuhongbo.com/2016/05/29/深入理解javascript/46代码复用模式（推荐篇）/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>