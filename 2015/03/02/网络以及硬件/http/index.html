<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> http · xuhongbo</title><meta name="description" content="http - xuhongbo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xuhongbo.com/atom.xml" title="xuhongbo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="https://github.com/xuhongbo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/abstract/" target="_self" class="nav-list-link">个人简介</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">http</h1><div class="post-info">Mar 2, 2015</div><div class="post-content"><p>超文本传输协议(HTTP，HyperText Transfer Protocol)</p>
<p>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。<br><a id="more"></a></p>
<p>超文本传输协议(HTTP，HyperText Transfer Protocol)</p>
<p>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
<p>HTTP的发展是万维网协会（World Wide Web Consortium）和Internet工作小组（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，其中最著名的就是RFC 2616。RFC 2616定义了HTTP协议的我们今天普遍使用的一个版本——HTTP 1.1。</p>
<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。</p>
<p>应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。</p>
<p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。</p>
<p>HTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。</p>
<p>通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p>
<blockquote>
<h3 id="2、请求信息Request-Message"><a href="#2、请求信息Request-Message" class="headerlink" title="2、请求信息Request Message"></a>2、请求信息Request Message</h3></blockquote>
<p>发出的请求信息包括以下几个</p>
<p>请求行，例如GET /images/logo.gif HTTP/1.1，表示从/images 目录下请求logo.gif 这个文件。<br>（请求）头，例如Accept-Language: en</p>
<p>空行</p>
<p>可选的消息体</p>
<p>请求行和标题必须以<cr><lf> 作为结尾（也就是，回车然后换行）。空行内必须只有<cr><lf>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。</lf></cr></lf></cr></p>
<blockquote>
<h3 id="3、请求方法"><a href="#3、请求方法" class="headerlink" title="3、请求方法"></a>3、请求方法</h3></blockquote>
<p>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>向指定资源位置上传其最新内容。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除指定资源。</p>
<h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>回显服务器收到的请求。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405(Method Not Allowed)；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501(Not Implemented)。</p>
<p>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当符合下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。<br>安全及幂等方法</p>
<blockquote>
<h3 id="安全方法"><a href="#安全方法" class="headerlink" title="安全方法"></a>安全方法</h3></blockquote>
<p>开发者应当意识到他们的软件代表了用户在因特网上进行交互，并且应当告知用户，他们正在进行的操作可能对他们自身或者其他人有未曾预料的重要影响。</p>
<p>特别地，对于GET和HEAD方法而言，除了进行获取资源信息外，这些请求不应当再有任何其他意义。也就是说，这些方法应当被认为是“安全的”。客户端应当使用其他“非安全”方法，例如POST，PUT及DELETE来以特殊的方式（通常是按钮而不是超链接）使得客户能够意识到可能要负的责任（例如一个按钮带来的资金交易）或者被告知正在请求的操作可能是不安全的（例如某个文件将被上传或删除）。</p>
<p>但是，不能想当然地认为服务器不会在处理某个GET请求时不会产生任何副作用。事实上，很多动态资源会把这作为其特性。这里重要的区别在于用户并没有请求这一副作用，因此不应由用户为这些副作用承担责任。</p>
<blockquote>
<h3 id="幂等方法"><a href="#幂等方法" class="headerlink" title="幂等方法"></a>幂等方法</h3></blockquote>
<p>假如在不考虑诸如错误或者过期等问题的情况下，若干次请求的副作用与单次请求相同或者根本没有副作用，那么这些请求方法就能够被视作“幂等”的。GET，HEAD，PUT和DELETE方法都有这样的幂等属性，同样由于根据协议，OPTIONS，TRACE都不应有副作用，因此也理所当然也是幂等的。</p>
<p>假如某个由若干个请求做成的请求序列产生的结果在重复执行这个请求序列或者其中任何一个或多个请求后仍没有发生变化，则这个请求序列便是“幂等”的。但是，可能出现若干个请求做成的请求序列是“非幂等”的，即使这个请求序列中所有执行的请求方法都是幂等的。例如，这个请求序列的结果依赖于某个会在下次执行这个序列的过程中被修改的变量。</p>
<blockquote>
<h3 id="4、协议版本号"><a href="#4、协议版本号" class="headerlink" title="4、协议版本号"></a>4、协议版本号</h3></blockquote>
<p>超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的。在RFC 2145中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。<br>0.9</p>
<p>已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。</p>
<blockquote>
<p><strong>HTTP/1.0</strong></p>
</blockquote>
<p>这是第一个在通讯中指定版本号的 HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。</p>
<blockquote>
<p><strong>HTTP/1.1</strong></p>
</blockquote>
<p>当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。</p>
<p><strong>HTTP/1.1</strong>相较于 <strong>HTTP/1.0</strong> 协议的区别主要体现在：</p>
<p>缓存处理</p>
<p>带宽优化及网络连接的使用</p>
<p>错误通知的管理</p>
<p>消息在网络中的发送</p>
<p>互联网地址的维护</p>
<p>安全性及完整性</p>
<blockquote>
<h3 id="5、状态行"><a href="#5、状态行" class="headerlink" title="5、状态行"></a>5、状态行</h3></blockquote>
<p>参见：HTTP状态码</p>
<p>所有 HTTP 响应的第一行都是状态行, 依次是当前 HTTP 版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p>
<p>状态代码的第一个数字代表当前响应的类型：</p>
<p><strong>1xx 消息</strong>——请求已被服务器接收，继续处理</p>
<p><strong>2xx 成功</strong>——请求已成功被服务器接收、理解、并接受</p>
<p><strong>3xx 重定向</strong>——需要后续操作才能完成这一请求</p>
<p><strong>4xx 请求错误</strong>——请求含有词法错误或者无法被执行</p>
<p><strong>5xx 服务器错误</strong>——服务器在处理某个正确请求时发生错误</p>
<p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是 WEB 开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p>
<blockquote>
<p><strong>HTTP是什么?</strong></p>
</blockquote>
<p>　　当我们想浏览一个网站的时候，只要在浏览器的地址栏里输入网站的地址就可以了，例如www.baidu.com,但是在浏览器的地址栏里面出现的却是：<a href="http://www.baidu.com/" target="_blank" rel="external">http://www.baidu.com</a> ,你知道为什么会多出一个“http”吗？</p>
<p>　　我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。因此，在我们认识HTTP之前，有必要先弄清楚URL的组成,例如：<a href="http://www.baidu.com/china/index.htm%E3%80%82%E5%AE%83%E7%9A%84%E5%90%AB%E4%B9%89%E5%A6%82%E4%B8%8B%EF%BC%9A" target="_blank" rel="external">http://www.baidu.com/china/index.htm。它的含义如下：</a></p>
<p>　　<strong>1. http://：</strong>代表超文本传输协议，通知baidu.com服务器显示Web页，通常不用输入；</p>
<p>　　<strong>2. www：</strong>代表一个Web（万维网）服务器；</p>
<p>　　<strong>3. baidu.com/：</strong>这是装有网页的服务器的域名，或站点服务器的名称；</p>
<p>　　<strong>4. China/：</strong>为该服务器上的子目录，就好像我们的文件夹；</p>
<p>　　<strong>5. Index.htm：index.htm</strong>是文件夹中的一个HTML文件（网页）。</p>
<p>　　我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。</p>
<p>　　<strong>HTTP协议</strong>（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以<a href="http://xn--8mrq9eb8bu7ib26a./" target="_blank" rel="external">http://开头的原因。</a></p>
<p>　　自WWW诞生以来，一个多姿多彩的资讯和虚拟的世界便出现在我们眼前，可是我们怎么能够更加容易地找到我们需要的资讯呢？当决定使用超文本作为WWW文档的标准格式后，于是在1990年，科学家们立即制定了能够快速查找这些超文本文档的协议，即HTTP协议。经过几年的使用与发展，得到不断的完善和扩展，目前在WWW中使用的是HTTP/1.0的第六版。</p>
<blockquote>
<p><strong>http 百科名片</strong></p>
</blockquote>
<p>超文本传输协议(HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
<blockquote>
<p><strong>目录</strong></p>
</blockquote>
<p><strong>简介</strong></p>
<p><strong>协议功能</strong></p>
<p><strong>协议基础</strong></p>
<p><strong>通用头域</strong></p>
<p><strong>Cache-Control头域</strong></p>
<p><strong>HTTP Keep-Alive</strong></p>
<p><strong>Date头域</strong></p>
<p><strong>Pragma头域</strong></p>
<p><strong>请求消息</strong></p>
<p><strong>Host头域</strong></p>
<p><strong>Referer头域</strong></p>
<p><strong>Range头域</strong></p>
<p><strong>User-Agent头域</strong></p>
<p><strong>响应消息</strong></p>
<p><strong>HTTP-运作方式</strong></p>
<p><strong>实体</strong></p>
<p><strong>Content-Type实体头</strong></p>
<p><strong>Last-modified实体头</strong></p>
<p><strong>协议结构</strong></p>
<p><strong>工作原理</strong></p>
<p><strong>状态消息</strong></p>
<p><strong>1xx:信息</strong></p>
<p><strong>2xx:成功</strong></p>
<p><strong>3xx:重定向</strong></p>
<p><strong>4xx:客户端错误</strong></p>
<p><strong>5xx:服务器错误</strong></p>
<p><strong>版本历史</strong></p>
<p><strong>协议版本0.9、HTTP/1.0、HTTP/1.1</strong></p>
<p>简介</p>
<p>协议功能、协议基础、通用头域、Cache-Control头域</p>
<p>HTTP Keep-Alive、Date头域、Pragma头域</p>
<p><strong>请求消息</strong></p>
<blockquote>
<p>Host头域、Referer头域、Range头域、User-Agent头域</p>
</blockquote>
<p><strong>响应消息</strong></p>
<blockquote>
<p>HTTP-运作方式、实体、Content-Type实体头、Last-modified实体头、协议结构、工作原理</p>
</blockquote>
<p><strong>状态消息</strong></p>
<blockquote>
<p>1xx:信息</p>
<p>2xx:成功</p>
<p>3xx:重定向</p>
<p>4xx:客户端错误</p>
<p>5xx:服务器错误</p>
</blockquote>
<p><strong>版本历史</strong></p>
<p><code>协议版本0.9、HTTP/1.0、HTTP/1.1</code></p>
<blockquote>
<h3 id="6、简介"><a href="#6、简介" class="headerlink" title="6、简介"></a>6、简介</h3></blockquote>
<p>HTTP的发展是万维网协会（World Wide Web Consortium）和Internet工作小组（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，其中最著名的就是RFC 2616。RFC 2616定义了HTTP协议的我们今天普遍使用的一个版本——HTTP 1.1。 　　</p>
<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。</p>
<p>在用户代理和源服务器中间可能存在 多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。 　　</p>
<p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。 HTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。 　　</p>
<p>通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p>
<blockquote>
<h3 id="7、协议功能"><a href="#7、协议功能" class="headerlink" title="7、协议功能"></a>7、协议功能</h3></blockquote>
<p>HTTP是超文本传输协议，是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。 　　</p>
<p>当我们想浏览一个网站的时候，只要在浏览器的地址栏里输入网站的地址就可以了，例如www.<strong>*</strong>.com,但是在浏览器的地址栏里面出现的却是：<a href="http://www.%2A%2A%2A%2A%2A%2A%2A%2C%E4%BD%A0%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA%E2%80%9Chttp%E2%80%9D%E5%90%97%EF%BC%9F/" target="_blank" rel="external">http://www.<strong><em>*</em></strong>,你知道为什么会多出一个“http”吗？</a> 　　</p>
<p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在 浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本转移协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。因此，在我们认识HTTP之前，有必要先弄清楚URL的组成,<br>例如：</p>
<p><a href="http://www.%2A%2A%2A%2A%2A%2A.com/china/index.htm%E3%80%82" target="_blank" rel="external">http://www.<strong>**</strong>.com/china/index.htm。</a></p>
<p>它的含义如下： 　　</p>
<ol>
<li><a href="http://xn--:%2C%2A%2A%2A%2A-gz9vr13cm76esggb39fczizl0f4bpn4j9oloie.xn--comweb%2C%3B-j49l99yfpdtqp8rzqvzwwc999f6pop28ggdci80e/" target="_blank" rel="external">http://：代表超文本转移协议，通知<em>**</em>.com服务器显示Web页，通常不用输入；</a> 　　</li>
<li>www：代表一个Web（万维网）服务器； 　　</li>
<li><strong>\</strong>.com/：这是装有网页的服务器的域名，或站点服务器的名称； 　　</li>
<li>China/：为该服务器上的子目录，就好像我们的文件夹； 　　</li>
<li>Index.htm：index.htm是文件夹中的一个HTML文件（网页）。 　　</li>
</ol>
<blockquote>
<p>我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。 　　</p>
</blockquote>
<p>HTTP协议（HyperText Transfer Protocol，超文本转移协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以<a href="http://xn--8mrq9eb8bu7ib26a./" target="_blank" rel="external">http://开头的原因。</a></p>
<p>自WWW诞生以来，一个多姿多彩的资讯和虚拟的世界便出现在我们眼前，可是我们怎么能够更加容易地找到我们需要的资讯呢？当决定使用超文本作为WWW文档的标准格式后，于是在1990年，科学家们立即制定了能够快速查找这些超文本文档的协议，即HTTP协议。经过几年的使用与发展，得到不断的完善和扩展，目前在WWW中使用的是HTTP/1.0的第六版。</p>
<blockquote>
<h3 id="8、协议基础"><a href="#8、协议基础" class="headerlink" title="8、协议基础"></a>8、协议基础</h3></blockquote>
<p>HTTP（HyperText Transfer Protocol）是超文本转移协议的缩写，它用于传送WWW方式的数据，关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。 　　</p>
<p>通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个指示头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<blockquote>
<h4 id="通用头域"><a href="#通用头域" class="headerlink" title="通用头域"></a>通用头域</h4></blockquote>
<p>　　通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。下面简单介绍几个在UPnP消息中使用的通用头域。</p>
<blockquote>
<h4 id="Cache-Control头域"><a href="#Cache-Control头域" class="headerlink" title="Cache-Control头域"></a>Cache-Control头域</h4></blockquote>
<p>　　Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括</p>
<blockquote>
<h4 id="no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，"><a href="#no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，" class="headerlink" title="no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，"></a>no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，</h4></blockquote>
<p>响应消息中的指令包括</p>
<blockquote>
<h3 id="public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。"><a href="#public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。" class="headerlink" title="public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。"></a>public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。</h3></blockquote>
<p>各个消息中的指令含义如下：<br>Public指示响应可被任何缓存区缓存。 　<br>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户 的部分响应消息，此响应消息对于其他用户的请求无效。 　　</p>
<p>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 　<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 　　</p>
<p>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 　　<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>
<blockquote>
<h4 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h4></blockquote>
<p>　　Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。市场上的大部分Web服务器，包括iPlanet、IIS和Apache，都支持HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。 　　</p>
<p>KeepAliveTime 值控制 TCP/IP 尝试验证空闲连接是否完好的频率。如果这段时间内没有活动，则会发送保持活动信号。如果网络工作正常，而且接收方是活动的，它就会响应。如果需要对丢失接收方敏感，换句话说，需要更快地发现丢失了接收方，请考虑减小这个值。如果长期不活动的空闲连接出现次数较多，而丢失接收方的情况出现较少，您可能会要提高该值以减少开销。缺省情况下，如果空闲连接 7200000 毫秒（2 小时）内没有活动，Windows 就发送保持活动的消息。通常，1800000 毫秒是首选值，从而一半的已关闭连接会在 30 分钟内被检测到。</p>
<p>KeepAliveInterval 值定义了如果未从接收方收到保持活动消息的响应，TCP/IP 重复发送保持活动信号的频率。当连续发送保持活动信号、但未收到响应的次数超出 TcpMaxDataRetransmissions 的值时，会放弃该连接。如果期望较长的响应时间，您可能需要提高该值以减少开销。如果需要减少花在验证接收方是否已丢失上的时间，请考虑减小该值或</p>
<p>TcpMaxDataRetransmissions 值。缺省情况下，在未收到响应而重新发送保持活动的消息之前，Windows 会等待 1000 毫秒（1 秒）。 KeepAliveTime 根据你的需要设置就行，比如10分钟，注意要转换成MS。 XXX代表这个间隔值得大小。</p>
<blockquote>
<h4 id="Date头域"><a href="#Date头域" class="headerlink" title="Date头域"></a>Date头域</h4></blockquote>
<p>　　Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>
<blockquote>
<h4 id="Pragma头域"><a href="#Pragma头域" class="headerlink" title="Pragma头域"></a>Pragma头域</h4></blockquote>
<p>　　Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。</p>
<blockquote>
<h4 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h4></blockquote>
<p>　　请求消息的第一行为下面的格式： 　<br>MethodSPRequest-URISPHTTP-VersionCRLFMethod</p>
<p>表示对于Request-URI完成的方法，这个字段是大小写敏感的，包括</p>
<p>OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE。</p>
<p>方法GET和HEAD应该被所有的通用<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=267249" target="_blank" rel="external">WEB服务器</a>支持，其他所有方法的实现是可选的。GET方法取回由Request-URI标识的信息。</p>
<p>HEAD方法也是取回由Request-URI标识的信息，只是可以在响应时，不返回消息体。POST方法可以请求服务器接收包含在请求中的实体信息，可以用于提交</p>
<p><a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=292881" target="_blank" rel="external">表单</a>，</p>
<p>向新闻组、BBS、邮件群组和数据库发送消息。 　　</p>
<p>SP表示空格。Request-URI遵循URI格式，在此字段为星号（*）时，说明请求并不用于某个特定的资源地址，而是用于服务器本身。HTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。</p>
<p>CRLF表示换行回车符。请求头域允许客户端向服务器传递关于请求或者关于客户机的附加信 息。请求头域可能包含下列字段</p>
<p>Accept、Accept-Charset、Accept-Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。</p>
<p>对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。 　　</p>
<p>典型的请求消息： 　<br><code>Host: download.*******.de 　　
Accept: */* 　　Pragma: no-cache 　　
Cache-Control: no-cache 　　
User-Agent: Mozilla/4.04[en](Win95;I;Nav) 　　
Range: bytes=554554-</code><br>上例第一行表示HTTP客户端（可能是浏览器、下载程序）通过GET方法获得指定URL下的文件。棕色的部分表示请求头域的信息，绿色的部分表示通用头部分。</p>
<blockquote>
<h4 id="Host头域"><a href="#Host头域" class="headerlink" title="Host头域"></a>Host头域</h4></blockquote>
<p>　　Host头域指定请求资源的Intenet主机和<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=17312" target="_blank" rel="external">端口号</a>，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8958983" target="_blank" rel="external">主机头</a>域，否则系统会以400状态码返回。</p>
<blockquote>
<h4 id="Referer头域"><a href="#Referer头域" class="headerlink" title="Referer头域"></a>Referer头域</h4></blockquote>
<p>　　Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=101504077" target="_blank" rel="external">相对地址</a>。</p>
<blockquote>
<h4 id="Range头域"><a href="#Range头域" class="headerlink" title="Range头域"></a>Range头域</h4></blockquote>
<p>　　Range头域可以请求实体的一个或者多个子范围。例如， 　　表示头500个字节：bytes=0-499 　　表示第二个500字节：bytes=500-999 　　表示最后500个字节：bytes=-500 　　表示500字节以后的范围：bytes=500- 　　第一个和最后一个字节：bytes=0-0,-1 　　同时指定几个范围：bytes=500-600,601-999 　　但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200（OK）。</p>
<blockquote>
<h4 id="User-Agent头域"><a href="#User-Agent头域" class="headerlink" title="User-Agent头域"></a>User-Agent头域</h4></blockquote>
<p>　　User-Agent头域的内容包含发出请求的用户信息。</p>
<p>响应消息<br>　　响应消息的第一行为下面的格式： 　　<br>HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF 　　<br>HTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。Status-Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可能取5个不同的值： 　　</p>
<p>1xx:信息响应类，表示接收到请求并且继续处理 　　</p>
<p>2xx:处理成功响应类，表示动作被成功接收、理解和接受 　　</p>
<p>3xx:<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=73770898" target="_blank" rel="external">重定向</a>响应类，为了完成指定的动作，必须接受进一步处理 　　</p>
<p>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 　　</p>
<p>5xx:服务端错误，服务器不能正确执行一个正确的请求 　　响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和Request-URI进一步的信息。响应头域包含</p>
<p>Age、Location、Proxy-Authenticate、Public、Retry-After、Server、Vary、Warning、WWW-Authenticate。</p>
<p>对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。 　　</p>
<p>典型的响应消息：<br>HTTP/1.0200OK 　　<br>Date:Mon,31Dec200104:25:57GMT 　　<br>Server:Apache/1.3.14(Unix) 　　<br>Content-type:text/html 　　<br>Last-modified:Tue,17Apr200106:46:28GMT 　　Etag:”a030f020ac7c01:1e9f” 　　<br>Content-length:39725426 　　<br>Content-range:bytes55<strong><em>\</em></strong>/40279980 　　</p>
<p>上例第一行表示HTTP服务端响应一个GET方法。棕色的部分表示响应头域的信息，绿色的部分表示通用头部分，红色的部分表示实体头域的信息。 　　<br>Location响应头 　　</p>
<p>Location响应头用于重定向接收者到一个新URI地址。<br>Server响应头 　　</p>
<p>Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。</p>
<blockquote>
<h4 id="HTTP-运作方式"><a href="#HTTP-运作方式" class="headerlink" title="HTTP-运作方式"></a>HTTP-运作方式</h4></blockquote>
<p>　　HTTP协议是基于请求／响应<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=1286086" target="_blank" rel="external">范式</a>的。一个客户机与<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=3850180" target="_blank" rel="external">服务器</a>建立连接后，发送一个请求给服务器，请求方式的格式为，统一资源标识符、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。服务器接到请求后，给予相应的响应信息，其格式为一个状态行包括信息的协议版本号、一个成功或错误的代码，</p>
<p>后边是<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=40102" target="_blank" rel="external">MIME</a>信息包括服务器信息、实体信息和可能的内容。 　　</p>
<p>许多HTTP通讯是由一个用户代理初始化的并且包括一个申请在源服务器上资源的请求。最简单的情况可能是在用户代理(UA)和源服务器(O)之间通过一个单独的连接来完成。 　　</p>
<p>当一个或多个中介出现在请求／响应链中时，情况就变得复杂一些。中介由三种：代理(Proxy)、<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=106777428" target="_blank" rel="external">网关</a>(Gateway)和通道(Tunnel)。</p>
<p>一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用.</p>
<p>实体<br>　　请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content- Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。</p>
<blockquote>
<h4 id="Content-Type实体头"><a href="#Content-Type实体头" class="headerlink" title="Content-Type实体头"></a>Content-Type实体头</h4></blockquote>
<p>　　Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型Content-Range实体头 　　</p>
<p>Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： 　　</p>
<p>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth 　　</p>
<p>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</p>
<blockquote>
<h4 id="Last-modified实体头"><a href="#Last-modified实体头" class="headerlink" title="Last-modified实体头"></a>Last-modified实体头</h4></blockquote>
<p>　　Last-modified实体头指定服务器上保存内容的最后修订时间。 　　</p>
<p>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。 　　</p>
<p>Last-modified实体头</p>
<blockquote>
<h3 id="9-协议结构"><a href="#9-协议结构" class="headerlink" title="9 协议结构"></a><em>9</em> 协议结构</h3></blockquote>
<p><a href="http://baike.sogou.com/Create.e?sp=2&amp;sp=l26357&amp;sp=28" target="_blank" rel="external">**编辑</a><br>　　HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。请求报文格式如下： 　　</p>
<p>请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体 　　</p>
<p>请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。SP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。 　　</p>
<p>应答报文格式如下： 　　</p>
<p>状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体 　　</p>
<p>状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。</p>
<blockquote>
<h3 id="10-工作原理"><a href="#10-工作原理" class="headerlink" title="10 工作原理"></a><em>10</em> 工作原理</h3></blockquote>
<p><a href="http://baike.sogou.com/Create.e?sp=2&amp;sp=l26357&amp;sp=29" target="_blank" rel="external">**编辑</a><br>　　既然我们明白了URL的构成，那么HTTP是怎么工作呢？我们接下来就要讨论这个问题。 　　</p>
<p>一次HTTP操作称为一个事务，其工作过程可分为四步： 　　</p>
<p>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作就开始了。 　　</p>
<p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7749920" target="_blank" rel="external">版本号</a>，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 　　</p>
<p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 　　</p>
<p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客 户机与服务器断开连接。 　　</p>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 　　</p>
<p>许多HTTP通讯是由一个用户代理初始化的并且包括一个申请在源服务器上资源的请求。最简单的情况可能是在用户代理和服务器之间通过一个单独的连接来完成。在Internet上，HTTP通讯通常发生在TCP/IP连接之上。缺省端口是TCP 80，但其它的端口也是可用的。但这并不预示着HTTP协议在Internet或其它网络的其它协议之上才能完成。HTTP只预示着一个可靠的传输。 　　</p>
<p>这个过程就好像我们打电话订货一样，我们可以打电话给商家，告诉他我们需要什么规格的商品，然后商家再告诉我们什么商品有货，什么商品缺货。这些，我们是通过电话线用电话联系（HTTP是通过TCP/IP），当然我们也可以通过传真，只要商家那边也有传真。 　　</p>
<p>以上简要介绍了HTTP协议的宏观运作方式，下面介绍一下HTTP协议的内部操作过程。 　　</p>
<p>在WWW中，“客户”与“服务器”是一个相对的概念，只存在于一个特定的连接期间，即在某个连接中的客户在另一个连接中可能作为服务器。基于HTTP协议的客户/服务器模式的信息交换过程，它分四个过程：建立连接、发送请求信息、发送响应信息、关闭连接。这就好像上面的例子，我们电话订货的全过程。 　　</p>
<p>其实简单说就是任何服务器除了包括HTML文件以外，还有一个HTTP驻留程序，用于响应用户请求。你的浏览器是HTTP客户，向服务器发送请求，当浏览器中输入了一个开始文件或点击了一个超级链接时，浏览器就向服务器发送了HTTP请求，此请求被送往由<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=17314" target="_blank" rel="external">IP地址</a>指定的URL。</p>
<p>驻留程序接收到请求，在进行必要的操作后回送所要求的文件。在这一过程中，在网络上发送和接收的数据已经被分成一个或多个数据包（packet），每个数据包包括：要传送的数据；控制信息，即告诉网络怎样处理数据包。TCP/IP决定了每个数据包的格式。如果事先不告诉你，你可能不会知道信息被分成用于传输和再重新组合起来的许多小块。 　　</p>
<p>也就是说商家除了拥有商品之外，它也有一个职员在接听你的电话，当你打电话的时候，你的声音转换成各种复杂的数据，通过电话线传输到对方的电话机，对方的电话机又把各种复杂的数据转换成声音，使得对方商家的职员能够明白你的请求。这个过程你不需要明白声音是怎么转换成复杂的数据的。</p>
<blockquote>
<h3 id="11、状态消息"><a href="#11、状态消息" class="headerlink" title="11、状态消息"></a>11、状态消息</h3></blockquote>
<p><a href="http://baike.sogou.com/Create.e?sp=2&amp;sp=l26357&amp;sp=30" target="_blank" rel="external">**编辑</a></p>
<p>1xx:信息</p>
<blockquote>
<p><strong>100 Continue</strong></p>
</blockquote>
<p>服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</p>
<blockquote>
<p><strong>101 Switching Protocols</strong></p>
</blockquote>
<p>服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</p>
<blockquote>
<p><strong>2xx:成功</strong></p>
</blockquote>
<p>消息:<br>描述:</p>
<blockquote>
<p><strong>200 OK</strong></p>
</blockquote>
<p>请求成功（其后是对GET和POST请求的应答文档。）</p>
<blockquote>
<p><strong>201 Created</strong></p>
</blockquote>
<p>请求被创建完成，同时新的资源被创建。</p>
<blockquote>
<p><strong>202 Accepted</strong></p>
</blockquote>
<p>供处理的请求已被接受，但是处理未完成。</p>
<blockquote>
<p><strong>203 Non-authoritative Information</strong></p>
</blockquote>
<p>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</p>
<blockquote>
<p><strong>204 No Content</strong></p>
</blockquote>
<p>没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</p>
<blockquote>
<p><strong>5 Reset Content</strong></p>
</blockquote>
<p>没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</p>
<blockquote>
<p><strong>06 Partial Content</strong></p>
</blockquote>
<p>客户发送了一个带有Range头的GET请求，服务器完成了它。</p>
<blockquote>
<p><strong>3xx:重定向</strong></p>
<p><strong>300 Multiple Choices</strong></p>
</blockquote>
<p>多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</p>
<blockquote>
<p><strong>301 Moved Permanently</strong></p>
</blockquote>
<p>所请求的页面已经转移至新的url。</p>
<blockquote>
<p><strong>302 Found</strong></p>
</blockquote>
<p>所请求的页面已经临时转移至新的url。</p>
<blockquote>
<p><strong>303 See Other</strong></p>
</blockquote>
<p>所请求的页面可在别的url下被找到。</p>
<blockquote>
<p><strong>304 Not Modified</strong></p>
</blockquote>
<p>未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p>
<blockquote>
<p><strong>305 Use Proxy</strong></p>
</blockquote>
<p>客户请求的文档应该通过Location头所指明的代理服务器提取。</p>
<blockquote>
<p><strong>306 *Unused</strong></p>
</blockquote>
<p>此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</p>
<blockquote>
<p><strong>307 Temporary Redirect</strong></p>
</blockquote>
<p>被请求的页面已经临时移至新的url。</p>
<blockquote>
<p><strong>4xx:客户端错误</strong></p>
<p><strong>400 Bad Request</strong></p>
</blockquote>
<p>服务器未能理解请求。</p>
<blockquote>
<p><strong>401 Unauthorized</strong></p>
</blockquote>
<p>被请求的页面需要用户名和密码。</p>
<blockquote>
<p><strong>402 Payment Required</strong></p>
</blockquote>
<p>此代码尚无法使用。</p>
<blockquote>
<p><strong>403 Forbidden</strong></p>
</blockquote>
<p>对被请求页面的访问被禁止。</p>
<blockquote>
<p><strong>404 Not Found</strong></p>
</blockquote>
<p>服务器无法找到被请求的页面。</p>
<blockquote>
<p><strong>405 Method Not Allowed</strong></p>
</blockquote>
<p>请求中指定的方法不被允许。</p>
<blockquote>
<p><strong>406 Not Acceptable</strong></p>
</blockquote>
<p>服务器生成的响应无法被客户端所接受。</p>
<blockquote>
<p><strong>407 Proxy Authentication Required</strong></p>
</blockquote>
<p>用户必须首先使用代理服务器进行验证，这样请求才会被处理。</p>
<blockquote>
<p><strong>408 Request Timeout</strong></p>
</blockquote>
<p>请求超出了服务器的等待时间。</p>
<blockquote>
<p><strong>409 Conflict</strong></p>
</blockquote>
<p>由于冲突，请求无法被完成。</p>
<blockquote>
<p><strong>410 Gone</strong></p>
</blockquote>
<p>被请求的页面不可用。</p>
<blockquote>
<p><strong>411 Length Required</strong></p>
</blockquote>
<p>“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</p>
<blockquote>
<p><strong>412 Precondition Failed</strong></p>
</blockquote>
<p>请求中的前提条件被服务器评估为失败。</p>
<blockquote>
<p><strong>413 Request Entity Too Large</strong></p>
</blockquote>
<p>由于所请求的实体的太大，服务器不会接受请求。</p>
<blockquote>
<p><strong>414 Request-url Too Long</strong></p>
</blockquote>
<p>由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</p>
<blockquote>
<p><strong>415 Unsupported Media Type</strong></p>
</blockquote>
<p>由于媒介类型不被支持，服务器不会接受请求。</p>
<blockquote>
<p><strong>416</strong></p>
</blockquote>
<p>服务器不能满足客户在请求中指定的Range头。</p>
<blockquote>
<p><strong>417 Expectation Failed</strong></p>
<p><strong>5xx:服务器错误</strong></p>
<p><strong>500 Internal Server Error</strong></p>
</blockquote>
<p>请求未完成。服务器遇到不可预知的情况。</p>
<blockquote>
<p><strong>501 Not Implemented</strong></p>
</blockquote>
<p>请求未完成。服务器不支持所请求的功能。</p>
<blockquote>
<p><strong>502 Bad Gateway</strong></p>
</blockquote>
<p>请求未完成。服务器从上游服务器收到一个无效的响应。</p>
<blockquote>
<p><strong>503 Service Unavailable</strong></p>
</blockquote>
<p>请求未完成。服务器临时过载或当机。</p>
<blockquote>
<p><strong>504 Gateway Timeout</strong></p>
</blockquote>
<p>网关超时。</p>
<blockquote>
<p><strong>505 HTTP Version Not Supported</strong></p>
</blockquote>
<p>服务器不支持请求中指明的HTTP协议版本。</p>
<blockquote>
<h3 id="12-版本历史"><a href="#12-版本历史" class="headerlink" title="12 版本历史"></a><em>12</em> 版本历史</h3><p><strong>协议版本</strong></p>
</blockquote>
<p>　　超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的。在RFC 2145中描述了HTTP 版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。</p>
<blockquote>
<p><strong>0.9</strong></p>
</blockquote>
<p>　　已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。</p>
<blockquote>
<p><strong>HTTP/1.0</strong></p>
</blockquote>
<p>　　这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=15561" target="_blank" rel="external">代理服务器</a>中。</p>
<blockquote>
<p><strong>HTTP/1.1</strong></p>
</blockquote>
<p>　　当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。<br>HTTP/1.1相较于 HTTP/1.0 协议的区别主要体现在：<br>1 缓存处理 　　</p>
<p>2 带宽优化及网络连接的使用 　　</p>
<p>3 错误通知的管理 　　</p>
<p>4 消息在网络中的发送 　　</p>
<p>5 互联网地址的维护 　　</p>
<p>6 安全性及完整性 词条图册更多图册</p>
<p><strong>1、网络传送带(影音传送带)</strong></p>
<p><strong>2、Configuring the HTTP Listener</strong></p>
<blockquote>
<h3 id="13-安全超文本传输协议"><a href="#13-安全超文本传输协议" class="headerlink" title="13 安全超文本传输协议"></a><em>13</em> 安全超文本传输协议</h3></blockquote>
<p>　　安全超文本传输协议（Secure Hypertext Transfer Protocol, S-HTTP）是一种结合HTTP而设计的消息的安全通信协议。S-HTTP协议为HTTP客户机和服务器提供了多种安全机制，这些安全服务选项是适用于Web上各类用户的。还为客户机和服务器提供了对称能力（及时处理请求和恢复，及两者的参数选择）同时维持HTTP的通信模型和实施特征。</p>
<p>　　S-HTTP不需要客户方的公用密钥证明，但它支持对称密钥的操作模式。这意味着在没有要求用户个人建立公用密钥的情况下，会自发地发生私人交易。它支持端对端安全传输，客户机可能首先启动安全传输（使用报头的信息），用来支持加密技术。</p>
<p>　　在语法上，S-HTTP报文与HTTP相同，由请求行或状态行组成，后面是信头和主体。请求报文的格式由请求行、通用信息头、请求头、实体头、信息主体组成。相应报文由响应行、通用信息头、响应头、实体头、信息主体组成。　</p>
<p>　　目前有两种方法来建立连接：HTTPS URI方案和HTTP 1.1请求头（由RFC2817引入）。由于浏览器对后者的几乎没有任何支持，因此HTTPS URI方案仍是建立安全超文本协议连接的主要手段。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2015/04/25/JavaScript/深入理解javascript/35设计模式之迭代器模式/" class="prev">PREV</a><a href="/2015/02/24/JavaScript/深入理解javascript/34设计模式之命令模式/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://github.com/xuhongbo" target="_blank">xuhongbo-github</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>